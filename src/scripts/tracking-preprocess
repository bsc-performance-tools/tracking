#!/usr/bin/perl

use Switch;

my $ARGC = @ARGV;

my $ClustersInfoSuffix = ".clusters_info.csv";
my $SequenceSuffix     = ".NOISE.seq";
my $AlignSuffix        = ".align";
my $PCFSuffix          = ".pcf";
my $CallersTemplate    = "@sub_TRACKING_PREFIX@/etc/CallersTemplate.cfg";
my $CALLERS_EVENT      = 80000000;

my $MinClusterPct      = 0;
my $CallersLevel       = 0;
my $CallersCFG         = "";
my $Reconstruct        = 0;
my $Verbose            = 0;
my $OutputPrefix       = "";
my $FixScaleDimensions = "";
my $MinimumScore       = "";

my @InputTraces          = ();
my @LastClusterToProcess = ();

sub PrintUsage
{
	print "TrackClusters [-c caller_level] [-m time_pct] [-o output_prefix] [-r] [-v] <TRACE1.prv> <TRACE2.prv> ... <TRACEn.prv>\n";
}

sub FilterIrrelevantClusters
{
    my ($Clustering, $MinPctTime) = @_;
    my $ClustersInfo = $Clustering.$ClustersInfoSuffix;

    my $PctDuration = `cat $ClustersInfo | grep "^%"`;
    chomp $PctDuration;
    my @arrayPctDuration = split (/,/, $PctDuration);

    my $ClusterName = `cat $ClustersInfo | grep "^Cluster Name"`;
    chomp $ClusterName;
    my @arrayClusterName = split (/,/, $ClusterName);

    my $i = $#arrayClusterName;
    my $found = 0;
    while (($i > 0) && ($found == 0))
    {
        if (($arrayPctDuration[$i] * 100) > $MinPctTime)
        {
            $found = 1;
        }
        else {
            $i --;
        }
    }

    if (!$found)
    {
        print "Error: All clusters are discarded! Try decreasing the minimum cluster time.\n";
        exit;
    }
    my @tmp = split (/ /, $arrayClusterName[$i]);
    my $LastClusterToCorrelate = $tmp[1];

    return $LastClusterToCorrelate;
}

if ($ARGC < 2)
{
	PrintUsage();
	exit;
}

my $i = 0;
for ($i = 0; ($i < $ARGC) && (substr($ARGV[$i], 0, 1) eq '-'); $i++)
{
	switch (substr($ARGV[$i], 1, 1))
	{
		case "f"
		{
			$i ++;
			$FixScaleDimensions = $ARGV[$i];
		}
		case "m"
		{
			$i ++;
			$MinClusterPct = $ARGV[$i];
			if (($MinClusterPct == 0 && $MinClusterPct ne '0') || ($MinClusterPct < 0) || ($MinClusterPct > 100))
			{
				print "*** Error: -m: Mininum cluster time percentage has to be between 0 and 100\n";
				exit;
			}
		}
		case "c"
		{
			$i ++;
			$CallersLevel = $ARGV[$i];
			if (($CallersLevel == 0 && $CallersLevel ne '0') || ($CallersLevel <= 0))
			{
				print "*** Error: -c: Callers level has to be greater than zero\n";
				exit;
			} 
		}
		case "o"
		{
			$i ++;
			$OutputPrefix = $ARGV[$i];
		}
		case "v"
		{
			$Verbose = 1;
		}
        case "r"
        {
            $Reconstruct = 1;
        }
        case "s"
        {
            $i ++;
            $MinimumScore = $ARGV[$i];
        }
		else
		{
			print "*** INVALID PARAMETER ".$ARGV[$i]."\n";
			PrintUsage();
			exit;
		}
	}
}	

if ($ARGC - $i < 2)
{
	# 2 traces at least
	PrintUsage();
	exit;
}

while ($i < $ARGC)
{
	if (! -e $ARGV[$i])
	{
		print "*** Error: Trace '$ARGV[$i]' not found.\n";
		PrintUsage();
		exit;
	}
	push (@InputTraces, $ARGV[$i]);
	$i ++;
}

print "+ Tracking configuration:\n";
print "Sequence of ".@InputTraces." clusterings.\n";
print "Minimum cluster time: ".$MinClusterPct."%\n";
print "Callers level: ".($CallersLevel > 0 ? "$CallersLevel" : "disabled")."\n";
print "Reconstruct traces: ".($Reconstruct == 1 ? "enabled" : "disabled")."\n";
print "\n";

print "+ Scaling plots and normalizing... ";
my $CMD = "@sub_TRACKING_PREFIX@/bin/ScaleNPlots.pl ";

if ($FixScaleDimensions ne "") 
{
	$CMD .= "-f $FixScaleDimensions ";
}
$CMD .= join(" ", @InputTraces);
`$CMD`;
print "done\n\n";

for ($i=0; $i<@InputTraces; $i++)
{
	my $CurrentTrace           = $InputTraces[$i];
	(my $TraceWithoutExtension = $CurrentTrace) =~ s/\.[^.]+$//;

	### Do the sequence alignment 
	my $AlignFile    = $TraceWithoutExtension.$AlignSuffix;
	my $SequenceFile = $TraceWithoutExtension.$SequenceSuffix;

#	if ( ! -e $AlignFile )
	{
		my $str = `basename $SequenceFile`;
		chomp $str; 

		if ( ! -e $SequenceFile )
		{
			print "Warning: Sequence file '$str' not found. Did you cluster with -a parameter?\n";
		}
		else
		{
            ### Preprocess sequence file to eliminate sequences that are NOISE ONLY
            my $SequenceFileProcessed = $SequenceFile.".tmp";
            open(SEQ, $SequenceFile) or die("Could not open sequence file '$str': $!\n");
            open(SEQ_TMP, ">$SequenceFileProcessed") or die("Could not open file for writing: $!\n");

            my $LastTaskLabel = "";
            foreach $Sequence (<SEQ>)  {   
                chomp($Sequence);
                if (substr($Sequence, 0, 1) eq ">")
                {
                  $LastTaskLabel = $Sequence; 
                } 
                else
                {
                  my $IsAllNoise = 1;
                  for (my $i=0; $i<length($Sequence); $i++)
                  {
                    if (substr($Sequence, $i, 1) ne "Z")
                    {
                      $IsAllNoise = 0;
                      last;
                    }
                  }
                  if ($IsAllNoise == 0)
                  {
                    print SEQ_TMP $LastTaskLabel."\n";
                    print SEQ_TMP $Sequence."\n";
                  }
                }
            }
            close(SEQ);
            close(SEQ_TMP);

			print "+ Aligning sequence file '$str'... ";
			`kalign -q $SequenceFileProcessed > $AlignFile`;
            `rm $SequenceFileProcessed`;
			print "done\n";
		}
	}
}
print "\n";

print "+ Filtering clusters under $MinClusterPct% of time...\n";
for ($i=0; $i<@InputTraces; $i++)
{
    my $CurrentTrace           = $InputTraces[$i];
    (my $TraceWithoutExtension = $CurrentTrace) =~ s/\.[^.]+$//;

	my $CurrentTraceLastCluster = FilterIrrelevantClusters($TraceWithoutExtension, $MinClusterPct);
	push (@LastClusterToProcess, $CurrentTraceLastCluster);
	my $str = `basename $CurrentTrace`;
	chomp $str;
	print "$CurrentTraceLastCluster clusters will be processed for trace ".($i+1)." ($str)\n";
}
print "\n";

if ($CallersLevel > 0)
{
	my $CallersEventType = $CALLERS_EVENT + $CallersLevel;	

    print "+ Checking whether traces have level $CallersLevel callstack events... ";
    for ($i=0; $i<@InputTraces; $i++)
    {
		my $CurrentTrace           = $InputTraces[$i];
		(my $TraceWithoutExtension = $CurrentTrace) =~ s/\.[^.]+$//;
		my $TracePCF = $TraceWithoutExtension.$PCFSuffix;

		my $CallersPresent = `cat $TracePCF | grep $CallersEventType`;
		if ($CallersPresent eq "")
		{
			$CallersLevel = 0;
			last;
        }
	}
	if ($CallersLevel > 0)
	{
		print "yes\n\n";

		print "+ Generating callers CFG... ";

		$CallersCFG = "CallersLvl$CallersLevel.cfg";
		`cat $CallersTemplate | sed "s/\@sub_CALLERS_LEVEL\@/$CallersEventType/g" > $CallersCFG`;
		print "done\n\n";
	}
	else
	{
		print "no (callstack tracking will be disabled)\n\n";
	}
}

print "+ Tracking clusters...\n";
$CMD="@sub_TRACKING_PREFIX@/bin/tracking.bin ";

if ($CallersLevel > 0)
{
	$CMD .= "-c $CallersCFG ";
}
if ($Reconstruct == 1)
{
    $CMD .= "-r ";
}
if ($MinimumScore ne "")
{
    $CMD .= "-s $MinimumScore ";
}
if ($Verbose == 1)
{
	$CMD .= "-v ";
}
if ($OutputPrefix ne "")
{
	$CMD .= "-o $OutputPrefix ";
}
for ($i=0; $i<@InputTraces; $i++)
{
	# This appends the last cluster to process per trace according to the percentage of time they represent
	$CMD .= $InputTraces[$i].":".$LastClusterToProcess[$i]." ";
	# $CMD .= $InputTraces[$i]." ";
}

system($CMD);
 
