#!/usr/bin/env python

import wxversion
wxversion.ensureMinimal('2.8')
import wx
import wx.aui
import wx.lib.buttons as buttons
import matplotlib
matplotlib.use('WXAgg')
import matplotlib.mlab as mlab
from matplotlib.figure import Figure
from matplotlib.backends.backend_wxagg import \
    FigureCanvasWxAgg as FigCanvas, \
    NavigationToolbar2WxAgg as NavigationToolbar
from matplotlib.patches import Polygon
from matplotlib.patches import FancyArrowPatch
import matplotlib.animation as animation
from matplotlib.lines import Line2D
import matplotlib.pyplot as plt
from collections import defaultdict
from scipy.interpolate import interp1d
from scipy.stats import nanmean
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
import math
import sys
import numpy as np
import convexhull as ch
import time
import os.path
import subprocess
import ConfigParser

INSTALLATION_PATH='@sub_PREFIX@/'

#
# Defines
#
matplotlib.rcParams.update({'font.size': 10})

CLUSTER_ID              = 'clusterid'
FIRST_CLUSTER_ID_CSV    =  6
INDEX_FIRST_METRIC_CSV  =  7
INDEX_LAST_METRIC_CSV   = -1
SIZE_EMPTY_HISTOGRAM    = 29 # This is the size of the header when the histogram is empty
VIEW_FRAMES     = 0
VIEW_TRAJECTORY = 1 
X = 0
Y = 1
Z = 2
HIDE_ALL       = 0
HIDE_SCATTERS  = 1
HIDE_CENTROIDS = 2
HIDE_HULLS     = 3
HIDE_ARROWS    = 4

#
# Global variables
#
Data             = { }
Callers          = { }
Metrics          = { }
NumberOfFrames   = 0
NumberOfClusters = 0
FirstCluster     = FIRST_CLUSTER_ID_CSV;
LastCluster      = FirstCluster
TasksPerFrame    = [ ]

#
# PRV color palette
#
ColorPalette      = [ ( 117, 195, 255 ), (   0,   0, 255 ), ( 255, 255, 255 ), ( 255,   0,   0 ), ( 255,   0, 174 ), ( 179,   0,   0 ), ( 0,   255,   0 ), ( 255, 255,   0 ), ( 235,   0,   0 ), (   0, 162,   0 ), ( 255,   0, 255 ), ( 100, 100,  177 ), ( 172, 174,  41 ), ( 255, 144,  26 ), (   2, 255, 177 ), ( 192, 224,   0 ), (  66,  66,  66 ), ( 189, 168, 100 ), (  95, 200,   0 ), ( 203,  60,  69 ), (   0, 109, 255 ), ( 200,  61,  68 ), ( 200,  66,   0 ), (   0,  41,   0 ), ( 139, 121, 177 ), ( 116, 116, 116 ), ( 200,  50,  89 ), ( 255, 171,  98 ), (   0,  68, 189 ), (  52,  43,   0 ), ( 255,  46,   0 ), ( 100, 216,  32 ), (   0,   0, 112 ), ( 105, 105,   0 ), ( 132,  75, 255 ), ( 184, 232,   0 ), (   0, 109, 112 ), ( 189, 168, 100 ), ( 132,  75,  75 ), ( 255,  75,  75 ), ( 255,  20,   0 ), (  52,   0,   0 ), (   0,  66,   0 ), ( 184, 132,   0 ), ( 100,  16,  32 ), ( 146, 255, 255 ), (   0,  23,  37 ), ( 146,   0, 255 ), (   0, 138, 119 ) ]
Color_Selected    = (0.20, 0.75, 0.80)
Color_NonSelected = (1, 1, 1)

def PRVColor(cluster_id):
    idx = cluster_id
    if (idx > len(ColorPalette)): idx = len(ColorPalette) - 1
    r = float(float(ColorPalette[idx][0]) / 255)
    g = float(float(ColorPalette[idx][1]) / 255)
    b = float(float(ColorPalette[idx][2]) / 255)
    rgb = (r, g, b)
    return rgb

#def MetricColor(metric):
#    return PRVColor( (Metrics[1].index(metric) + 20) % len(ColorPalette))

def ClusterOffset(cluster_id):
    return cluster_id - FirstCluster + 1

def isClusteringDimension(metric_name):
  if (metric_name[0:2] == 'd_'):
    return 1
  return 0

def isExtrapolatedMetric(metric_name):
  if (metric_name[0:2] == 'x_'):
    return 1
  return 0


class ToolbarL(NavigationToolbar):
  #
  # Extend the default wx toolbar with your own event handlers
  #  
  ON_SCATTER_CHECK = wx.NewId()
  ON_CENTROID_CHECK = wx.NewId()
  ON_HULL_CHECK = wx.NewId()

  def __init__(self, canvas):
    NavigationToolbar.__init__(self, canvas)

    self.AddSeparator()

    self.AddCheckTool(
      self.ON_SCATTER_CHECK,
      wx.Bitmap(INSTALLATION_PATH+'etc/icons/scatter.png'),
      wx.Bitmap(INSTALLATION_PATH+'etc/icons/scatter.png'),
      'Draw the points of the cluster',
      'Draw the points of the cluster')

    self.AddCheckTool(
      self.ON_CENTROID_CHECK,
      wx.Bitmap(INSTALLATION_PATH+'etc/icons/centroid.png'),
      wx.Bitmap(INSTALLATION_PATH+'etc/icons/centroid.png'),
      'Draw the centroid of the cluster',
      'Draw the centroid of the cluster')

    self.CheckHull = self.AddCheckTool(
      self.ON_HULL_CHECK,
      wx.Bitmap(INSTALLATION_PATH+'etc/icons/hull.png'),
      wx.Bitmap(INSTALLATION_PATH+'etc/icons/hull.png'),
      'Draw the perimeter of the cluster',
      'Draw the perimeter of the cluster')

    self.ToggleTool(self.ON_SCATTER_CHECK, True)

    wx.EVT_TOOL(self, self.ON_SCATTER_CHECK, self.on_Scatter_Check)
    wx.EVT_TOOL(self, self.ON_HULL_CHECK, self.on_Hull_Check)
    wx.EVT_TOOL(self, self.ON_CENTROID_CHECK, self.on_Centroid_Check)
   
  def on_Scatter_Check(self, event):
    if (self.GetToolState(self.ON_SCATTER_CHECK) == True):
      app.main.Display_Scatters()
    else:
      app.main.Hide_Objects(HIDE_SCATTERS)
    app.main.CanvasL.draw()

  def on_Centroid_Check(self, event):
    if (self.GetToolState(self.ON_CENTROID_CHECK) == True):
      app.main.Display_Centroids()
    else:
      app.main.Hide_Objects(HIDE_CENTROIDS)
    app.main.CanvasL.draw()

  def on_Hull_Check(self, event):
    if (self.GetToolState(self.ON_HULL_CHECK) == True):
      app.main.Display_Hulls()
    else:
      app.main.Hide_Objects(HIDE_HULLS)
    app.main.CanvasL.draw()

class ToolbarR(NavigationToolbar):
  #
  # Extend the default wx toolbar with your own event handlers
  #  
  ON_BOXPLOT_CHECK = wx.NewId()
  ON_INTERPOLATE_CHECK = wx.NewId()
  ON_LEGEND_CHECK = wx.NewId()

  def __init__(self, canvas):
    NavigationToolbar.__init__(self, canvas)

    self.AddSeparator()

    self.AddCheckTool(
      self.ON_BOXPLOT_CHECK,
      wx.Bitmap(INSTALLATION_PATH+'etc/icons/boxplot.png'),
      wx.Bitmap(INSTALLATION_PATH+'etc/icons/boxplot.png'),
      'Switch between boxplots and trend lines',
      'Switch between boxplots and trend lines')

    self.AddCheckTool(
      self.ON_INTERPOLATE_CHECK,
      wx.Bitmap(INSTALLATION_PATH+'etc/icons/heatmap.png'),
      wx.Bitmap(INSTALLATION_PATH+'etc/icons/heatmap.png'),
      'Interpolate the heat map',
      'Interpolate the heat map')

    self.AddCheckTool(
      self.ON_LEGEND_CHECK,
      wx.Bitmap(INSTALLATION_PATH+'etc/icons/legend.png'),
      wx.Bitmap(INSTALLATION_PATH+'etc/icons/legend.png'),
      'Show plots legends',
      'Show plots legends')

    self.ToggleTool(self.ON_LEGEND_CHECK, True)

    wx.EVT_TOOL(self, self.ON_BOXPLOT_CHECK, self.on_Boxplot_Check)
    wx.EVT_TOOL(self, self.ON_INTERPOLATE_CHECK, self.on_Interpolate_Check)
    wx.EVT_TOOL(self, self.ON_LEGEND_CHECK, self.on_Legend_Check)

  def on_Boxplot_Check(self, event):
      app.main.PlotR()

  def on_Interpolate_Check(self, event):
      app.main.PlotR()

  def on_Legend_Check(self, event):
      app.main.PlotR()


class MainFrame(wx.Frame, animation.TimedAnimation):
  #
  # The main frame of the application
  #

  def __init__(self, parent, title):
    #
    # A "-1" in the size parameter instructs wxWidgets to use the default size.
    #
    wx.Frame.__init__(self, parent, title=title)

    self.Scatters     = defaultdict()
    self.Hulls        = defaultdict()
    self.Centroids    = defaultdict()
    self.Trajectories = defaultdict()
    self.Arrows       = defaultdict(list)
    # self.Paths = defaultdict()
    # self.Xi = defaultdict()
    # self.Yi = defaultdict()
    self.DisplayingClusters = defaultdict()
    self.DisplayingMetrics  = defaultdict()
 
    self.XRange       = defaultdict()
    self.YRange       = defaultdict()
    self.ZRange       = defaultdict()
    self.XRangeScaled = defaultdict()
    self.YRangeScaled = defaultdict()
    self.ZRangeScaled = defaultdict()

    self.Bins = 25

    # 
    self.bmp_display   = wx.Bitmap(INSTALLATION_PATH+"etc/icons/display.png")
    self.bmp_nodisplay = wx.Bitmap(INSTALLATION_PATH+"etc/icons/nodisplay.png")
    self.bmp_play      = wx.Bitmap(INSTALLATION_PATH+"etc/icons/play.png")
    self.bmp_prev      = wx.Bitmap(INSTALLATION_PATH+"etc/icons/prev.png")
    self.bmp_next      = wx.Bitmap(INSTALLATION_PATH+"etc/icons/next.png")
    self.bmp_log_on    = wx.Bitmap(INSTALLATION_PATH+"etc/icons/log_on.png")
    self.bmp_log_off   = wx.Bitmap(INSTALLATION_PATH+"etc/icons/log_off.png")
    
    self.LoadData()

    self.Create_Main_Panel()

    self.PlotL()

    # self.SetupView()

    # self.ComputePlots()

    # self.PlotAll()
    # self.FigR.subplots_adjust(left=0.06, bottom=0.05, right=0.99, top=0.95, wspace=0.11, hspace=0.19)

  def Create_Main_Panel(self):

    self.Panel = wx.Panel(self)
        
    #
    # Create the mpl Figures and Canvas objects (5x4 inches, 100 dots-per-inch)
    #
    self.DPI     = 100
    self.FigL    = Figure((5, 4), dpi=self.DPI)
    self.CanvasL = FigCanvas(self.Panel, -1, self.FigL)
    self.AxesL   = self.FigL.add_subplot(111)
    self.FigL.set_facecolor("#FFFFFF")

    # self.FigR     = Figure((5.0, 4.0), dpi=self.DPI)
    # self.CanvasR  = FigCanvas(self.Panel, -1, self.FigR)
    # self.ColorBar = ()
    # self.FigR.set_facecolor("#FFFFFF")

    #
    # Create the navigation toolbars, tied to the canvas
    #
    self.ToolbarL = ToolbarL(self.CanvasL)
    # self.ToolbarR = ToolbarR(self.CanvasR)

    #
    # Axes frame
    #
    self.AxesBox       = wx.StaticBox(self.Panel, -1, "Axes") 
    self.AxesBoxSizer  = wx.StaticBoxSizer(self.AxesBox, wx.HORIZONTAL)    
    self.AxesBoxSizer1 = wx.BoxSizer(wx.VERTICAL)
    self.AxesBoxSizer2 = wx.BoxSizer(wx.VERTICAL)
    self.AxesBoxSizer3 = wx.BoxSizer(wx.VERTICAL)
    self.AxesBoxSizer4 = wx.BoxSizer(wx.VERTICAL)
    self.AxesBoxSizer.Add( self.AxesBoxSizer1 )
    self.AxesBoxSizer.Add( self.AxesBoxSizer2 )
    self.AxesBoxSizer.Add( self.AxesBoxSizer3 )
    self.AxesBoxSizer.Add( self.AxesBoxSizer4 )

    # Swap button
    self.AxesSwapButton   = wx.Button(self.Panel, -1, "Swap", size=(60,60))
    self.Bind(wx.EVT_BUTTON, self.on_Swap_Button, self.AxesSwapButton)

    # 3D button
    self.Activate3DButton = wx.ToggleButton(self.Panel, -1, "3D", size=(60,30), style=wx.EXPAND)
    self.Bind(wx.EVT_TOGGLEBUTTON, self.on_3D_Button, self.Activate3DButton)

    # X, Y, Z axes combos
    self.XAxisCombo = wx.ComboBox(self.Panel, -1, choices=Metrics[self.FocusOnFrame], size=(-1,30), style=wx.CB_READONLY)
    self.XAxisCombo.SetSelection(1)
    self.YAxisCombo = wx.ComboBox(self.Panel, -1, choices=Metrics[self.FocusOnFrame], size=(-1,30), style=wx.CB_READONLY)
    self.YAxisCombo.SetSelection(0)
    self.ZAxisCombo = wx.ComboBox(self.Panel, -1, choices=Metrics[self.FocusOnFrame], size=(-1,30), style=wx.CB_READONLY)
    if (len(Metrics[self.FocusOnFrame]) > 2):
      self.ZAxisCombo.SetSelection(2)
    self.ZAxisCombo.Disable()
    self.Bind(wx.EVT_COMBOBOX, self.on_XAxisCombo_Change, self.XAxisCombo)
    self.Bind(wx.EVT_COMBOBOX, self.on_YAxisCombo_Change, self.YAxisCombo)
    self.Bind(wx.EVT_COMBOBOX, self.on_ZAxisCombo_Change, self.ZAxisCombo)

    # Log scale buttons
    self.XAxisLogButton = wx.BitmapButton(self.Panel, -1, size=(30,30), bitmap=self.bmp_log_off)
    self.Bind(wx.EVT_BUTTON, self.on_XLog_Button, self.XAxisLogButton)
    self.YAxisLogButton = wx.BitmapButton(self.Panel, -1, size=(30,30), bitmap=self.bmp_log_off)
    self.Bind(wx.EVT_BUTTON, self.on_YLog_Button, self.YAxisLogButton)
    self.ZAxisLogButton = wx.BitmapButton(self.Panel, -1, size=(30,30), bitmap=self.bmp_log_off)
    self.Bind(wx.EVT_BUTTON, self.on_ZLog_Button, self.ZAxisLogButton)
    self.ZAxisLogButton.Disable()
    self.LogState = [0, 0, 0]

    # Scale to number of tasks buttons
    self.XAxisScaleButton = wx.BitmapButton(self.Panel, -1, size=(30,30), bitmap=self.bmp_log_off)
    self.Bind(wx.EVT_BUTTON, self.on_XScale_Button, self.XAxisScaleButton)
    self.YAxisScaleButton = wx.BitmapButton(self.Panel, -1, size=(30,30), bitmap=self.bmp_log_off)
    self.Bind(wx.EVT_BUTTON, self.on_YScale_Button, self.YAxisScaleButton)
    self.ZAxisScaleButton = wx.BitmapButton(self.Panel, -1, size=(30,30), bitmap=self.bmp_log_off)
    self.Bind(wx.EVT_BUTTON, self.on_ZScale_Button, self.ZAxisScaleButton)
    self.ZAxisScaleButton.Disable()
    self.ScaleState     = [0, 0, 0]
    self.PrevScaleState = [0, 0, 0]

    # Arrange the widgets
    self.AxesBoxSizer1.Add( self.AxesSwapButton, 0, wx.ALIGN_LEFT | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    self.AxesBoxSizer1.Add( self.Activate3DButton, 0, wx.ALIGN_LEFT | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    self.AxesBoxSizer2.Add( self.XAxisCombo, 0, wx.ALIGN_LEFT | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    self.AxesBoxSizer2.Add( self.YAxisCombo, 0, wx.ALIGN_LEFT | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    self.AxesBoxSizer2.Add( self.ZAxisCombo, 0, wx.ALIGN_LEFT | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    self.AxesBoxSizer3.Add( self.XAxisLogButton, 0, wx.ALIGN_LEFT | wx.ALIGN_CENTER_VERTICAL)
    self.AxesBoxSizer3.Add( self.YAxisLogButton, 0, wx.ALIGN_LEFT | wx.ALIGN_CENTER_VERTICAL)
    self.AxesBoxSizer3.Add( self.ZAxisLogButton, 0, wx.ALIGN_LEFT | wx.ALIGN_CENTER_VERTICAL)
    self.AxesBoxSizer4.Add( self.XAxisScaleButton, 0, wx.ALIGN_LEFT | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    self.AxesBoxSizer4.Add( self.YAxisScaleButton, 0, wx.ALIGN_LEFT | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    self.AxesBoxSizer4.Add( self.ZAxisScaleButton, 0, wx.ALIGN_LEFT | wx.ALL | wx.ALIGN_CENTER_VERTICAL)

    # #
    # # Create the buttons
    # #
    # self.ViewModeBox = wx.StaticBox(self.Panel, -1, "View mode", style=wx.EXPAND)
    # self.ViewModeBoxSizer = wx.StaticBoxSizer(self.ViewModeBox, wx.HORIZONTAL)
    # self.ViewButton = wx.ToggleButton(self.Panel, -1, "Switch to "+VIEW_TRAJECTORY+" view")
    # self.ViewModeBoxSizer.Add( self.ViewButton, 1, wx.EXPAND )
    # self.Bind(wx.EVT_TOGGLEBUTTON, self.on_View_Button, self.ViewButton)

    #
    # Frame selector 
    #
    self.FrameBox      = wx.StaticBox(self.Panel, -1, "Select frame", style=wx.EXPAND)
    self.FrameBoxSizer = wx.StaticBoxSizer(self.FrameBox, wx.HORIZONTAL)
    self.PrevButton = wx.BitmapButton(self.Panel, -1, size=(30,30), bitmap=self.bmp_prev)
    self.Bind(wx.EVT_BUTTON, self.on_Prev_Button, self.PrevButton)
    self.NextButton = wx.BitmapButton(self.Panel, -1, size=(30,30), bitmap=self.bmp_next)
    self.Bind(wx.EVT_BUTTON, self.on_Next_Button, self.NextButton)
    self.PlayButton = wx.BitmapButton(self.Panel, -1, size=(30,30), bitmap=self.bmp_play)
    self.Bind(wx.EVT_BUTTON, self.on_Play_Button, self.PlayButton)
    self.FrameSlider = wx.Slider(self.Panel, -1,
      value=self.FocusOnFrame, 
      minValue=1,
      maxValue=NumberOfFrames,
      style=wx.SL_HORIZONTAL | wx.SL_AUTOTICKS)
    self.FrameSlider.SetTickFreq(1, 1)
    self.Bind(wx.EVT_COMMAND_SCROLL_CHANGED, self.on_Frame_Change, self.FrameSlider)
    self.TrajectoryButton = wx.BitmapButton(self.Panel, -1, size=(90,30), bitmap=self.bmp_log_on)
    self.Bind(wx.EVT_BUTTON, self.on_Trajectory_Button, self.TrajectoryButton)

    self.FrameBoxSizer.Add( self.PrevButton,       0, wx.ALIGN_LEFT  | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    self.FrameBoxSizer.Add( self.FrameSlider,      1, wx.EXPAND      | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    self.FrameBoxSizer.Add( self.NextButton,       0, wx.ALIGN_RIGHT | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    self.FrameBoxSizer.Add( self.TrajectoryButton, 0, wx.ALIGN_RIGHT | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    self.FrameBoxSizer.Add( self.PlayButton,       0, wx.ALIGN_LEFT  | wx.ALL | wx.ALIGN_CENTER_VERTICAL)

    # #
    # # 
    # #
    # self.HeatMapConfigBox = wx.StaticBox(self.Panel, -1, "Heat map resolution", style=wx.EXPAND)
    # self.HeatMapConfigBoxSizer = wx.StaticBoxSizer(self.HeatMapConfigBox, wx.HORIZONTAL)
    # self.ResolutionSlider = wx.Slider(self.Panel, -1,
    #   value=25,
    #   minValue=5,
    #   maxValue=50,
    #   style=wx.SL_HORIZONTAL | wx.SL_AUTOTICKS | wx.SL_LABELS)
    # self.ResolutionSlider.SetTickFreq(1, 1)
    # self.Bind(wx.EVT_COMMAND_SCROLL_CHANGED, self.on_Resolution_Change, self.ResolutionSlider)
    # self.HeatMapConfigBoxSizer.Add( self.ResolutionSlider, 1, wx.EXPAND )

    # self.PredictionBox = wx.StaticBox(self.Panel, -1, "Predict", style=wx.EXPAND)
    # self.PredictionBoxSizer = wx.StaticBoxSizer(self.PredictionBox, wx.HORIZONTAL )
    # self.PredictExperiments = wx.TextCtrl(self.Panel, -1, size=(100, 26), style=wx.TE_PROCESS_ENTER)
    # self.PredictExperiments.SetValue("0")

    # self.Bind(wx.EVT_TEXT_ENTER, self.on_Prediction_Change, self.PredictExperiments)

    # RegressionTypeList = ['Linear', 'Curve-2', 'Curve-3']
    # self.RegressionTypeCombo = wx.ComboBox( self.Panel, -1, value=RegressionTypeList[0], size=(100, 26), choices=RegressionTypeList, style=wx.CB_DROPDOWN)
    # self.Bind(wx.EVT_COMBOBOX, self.on_RegressionType_Change, self.RegressionTypeCombo)

    # self.PredictionBoxSizer.Add( self.PredictExperiments, 1, wx.ALIGN_CENTER_VERTICAL)
    # self.PredictionBoxSizer.Add( self.RegressionTypeCombo, 1, wx.ALIGN_CENTER_VERTICAL)

    # #
    # # Create timers
    # #
    # self.PlayTimer = wx.Timer(self)
    # self.Bind(wx.EVT_TIMER, self.on_Playing_Timer, self.PlayTimer)

#    #
##    # Clusters scroll
##    #
##    self.ClustersScroll     = wx.ScrolledWindow(self.Panel, -1, style=wx.VSCROLL | wx.HSCROLL | wx.ALWAYS_SHOW_SB)
##    self.ClustersScrollList = []
    for cluster_id in range(FirstCluster, LastCluster+1):
##      ClustersDisplayToggle = wx.BitmapButton(self.ClustersScroll, -1, bitmap=self.bmp_display, size=(26, 26), name=str(cluster_id))   
##      ClustersFocusToggle   = wx.ToggleButton(self.ClustersScroll, -1, "Region "+str(cluster_id-FirstCluster+1), size=(-1,26), name=str(cluster_id))
##      self.Bind(wx.EVT_BUTTON, self.on_Clusters_Display, ClustersDisplayToggle)
##      self.Bind(wx.EVT_TOGGLEBUTTON, self.on_Clusters_Focus, ClustersFocusToggle)
##      c = PRVColor(cluster_id)
##      ClustersDisplayToggle.SetBackgroundColour(wx.Colour(c[0]*255, c[1]*255, c[2]*255))
##      self.ClustersScrollList.append((ClustersDisplayToggle, ClustersFocusToggle))
      self.DisplayingClusters[cluster_id] = True
##
##    ClustersScrollSizer = wx.BoxSizer(wx.VERTICAL)
##    for controls in self.ClustersScrollList:
##      ClustersScrollSizerH = wx.BoxSizer(wx.HORIZONTAL)
##      ClustersScrollSizerH.Add(controls[0], 0, wx.ALIGN_LEFT)
##      ClustersScrollSizerH.Add(controls[1], 0, wx.ALIGN_LEFT)
##      ClustersScrollSizer.Add(ClustersScrollSizerH)
##
##    self.ClustersLegendBox = wx.StaticBox(self.Panel, -1, "Display regions", style=wx.EXPAND)
##    self.ClustersLegendBoxSizer = wx.StaticBoxSizer(self.ClustersLegendBox, wx.VERTICAL)
##
##    self.ClustersScroll.SetSizer(ClustersScrollSizer)
##    self.ClustersScroll.SetScrollbars(1, 1, 1, 1)
##    self.ClustersLegendBoxSizer.Add( self.ClustersScroll, 1, wx.EXPAND )
##    self.set_Cluster_Focus(FirstCluster)
##
##    #
##    # Metrics scroll
##    #
##    self.MetricsScroll     = wx.ScrolledWindow(self.Panel, -1, style=wx.VSCROLL | wx.HSCROLL | wx.ALWAYS_SHOW_SB)
##    self.MetricsScrollList = []
##    for metric in Metrics[1]:
##      if (isClusteringDimension(metric)):
##        display_by_default = True
##        bitmap = self.bmp_display
##      else:
##        display_by_default = False
##        bitmap = self.bmp_nodisplay
##
##      MetricsDisplayToggle = wx.BitmapButton(self.MetricsScroll, -1, bitmap=bitmap, size=(26, 26), name=metric)
##      MetricsFocusToggle   = wx.ToggleButton(self.MetricsScroll, -1, metric.upper()[2:], size=(-1,26), name=metric)
##
##      self.Bind(wx.EVT_BUTTON, self.on_Metrics_Display, MetricsDisplayToggle)
##      self.Bind(wx.EVT_TOGGLEBUTTON, self.on_Metrics_Focus, MetricsFocusToggle)
##      c = MetricColor(metric)
##      MetricsDisplayToggle.SetBackgroundColour(wx.Colour(c[0]*255, c[1]*255, c[2]*255))
##      self.MetricsScrollList.append((MetricsDisplayToggle, MetricsFocusToggle))
##      self.DisplayingMetrics[metric] = display_by_default
##
##    MetricsScrollSizer = wx.BoxSizer(wx.VERTICAL)
##    for controls in self.MetricsScrollList:
##      MetricsScrollSizerH = wx.BoxSizer(wx.HORIZONTAL)
##      MetricsScrollSizerH.Add(controls[0], 0, wx.ALIGN_LEFT)
##      MetricsScrollSizerH.Add(controls[1], 0, wx.ALIGN_LEFT)
##      MetricsScrollSizer.Add(MetricsScrollSizerH)
##
##    self.MetricsLegendBox = wx.StaticBox(self.Panel, -1, "Display metrics", style=wx.EXPAND)
##    self.MetricsLegendBoxSizer = wx.StaticBoxSizer(self.MetricsLegendBox, wx.VERTICAL)
##
##    self.MetricsScroll.SetSizer(MetricsScrollSizer)
##    self.MetricsScroll.SetScrollbars(1, 1, 1, 1)
##    self.MetricsLegendBoxSizer.Add( self.MetricsScroll, 1, wx.EXPAND )
##    self.set_Metric_Focus(Metrics[1][0])
#
    #
    # General layout 
    #
    self.PlotLBox = wx.BoxSizer(wx.VERTICAL)
    self.PlotLBox.Add(self.CanvasL, 1, wx.LEFT | wx.TOP | wx.GROW)
    self.PlotLBox.Add(self.ToolbarL, 0)
    self.PlotLBox.AddSpacer(10)

    self.PlotLControls1 = wx.BoxSizer(wx.HORIZONTAL)
    self.PlotLControls1.Add(self.AxesBoxSizer, 1, wx.EXPAND | wx.ALL | wx.ALIGN_CENTER_VERTICAL)

    # self.PlotLControls2 = wx.BoxSizer(wx.HORIZONTAL)
    # self.PlotLControls2.Add(self.ViewModeBoxSizer, 1, wx.EXPAND | wx.ALL | wx.ALIGN_CENTER_VERTICAL)

    self.PlotLControls3 = wx.BoxSizer(wx.HORIZONTAL)
    self.PlotLControls3.Add( self.FrameBoxSizer, 1, wx.EXPAND )

    # self.PlotLControls4 = wx.BoxSizer(wx.HORIZONTAL)
    # self.PlotLControls4.Add( self.HeatMapConfigBoxSizer, 1, wx.EXPAND | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    # self.PlotLControls4.Add( self.PredictionBoxSizer, 1, wx.EXPAND | wx.ALL | wx.ALIGN_CENTER_VERTICAL)

    self.PlotLBox.Add(self.PlotLControls1, 0, flag = wx.TOP | wx.EXPAND)
    # self.PlotLBox.Add(self.PlotLControls2, 0, flag = wx.TOP | wx.EXPAND)
    self.PlotLBox.Add(self.PlotLControls3, 0, flag = wx.TOP | wx.EXPAND)
    # self.PlotLBox.Add(self.PlotLControls4, 0, flag = wx.TOP | wx.EXPAND)

    # self.PlotBoxR = wx.BoxSizer(wx.VERTICAL)
    # self.PlotBoxR.Add(self.CanvasR, 1, wx.LEFT | wx.TOP | wx.GROW)
    # self.PlotBoxR.Add(self.ToolbarR, 0)

#    self.LegendBox = wx.BoxSizer(wx.VERTICAL)
#    self.LegendBox.Add(self.ClustersLegendBoxSizer, 1, wx.EXPAND)
#    self.LegendBox.Add(self.MetricsLegendBoxSizer, 1, wx.EXPAND)

    self.WindowBox = wx.BoxSizer(wx.HORIZONTAL)
    self.WindowBox.Add(self.PlotLBox, 3, wx.EXPAND)
#    self.WindowBox.Add(self.LegendBox, 1, wx.EXPAND)
    # self.WindowBox.Add(self.PlotBoxR, 5, wx.EXPAND)

    self.Panel.SetSizer(self.WindowBox)
    self.WindowBox.Fit(self)

    self.SetMinSize(self.GetSize())
    self.CurrentView = VIEW_FRAMES

  def LoadData(self):
    global LastCluster
    global NumberOfClusters
    global TasksPerFrame

    for frame in range(1, NumberOfFrames+1):
      config = ReadConfig('Frame '+str(frame))

      # Load the CSV data file 
      csv = config['data']
      if not os.path.isfile(csv):
        csv = os.path.dirname(sys.argv[1]) + "/" + csv
      Data[frame] = mlab.csv2rec(csv)

      # Read the list of metrics from the first frame (assumes all frames have the same metrics!)
      current_metrics = Data[frame].dtype.names[INDEX_FIRST_METRIC_CSV:INDEX_LAST_METRIC_CSV]
      # Filter the normalized metrics, we only plot the clustering dimensions and the extrapolated metrics
      Metrics[frame] = [m for m in current_metrics if isClusteringDimension(m) or isExtrapolatedMetric(m)]

      # Load the callers histogram        
      if 'callers' in config:
        histogram = config['callers']
        if not os.path.isfile(histogram):
          histogram = os.path.dirname(sys.argv[1]) + "/" + histogram
        # Ensure the histogram is not empty (may happen when all callers are unresolved)
        if (os.path.getsize(histogram) > SIZE_EMPTY_HISTOGRAM):
          Callers[frame] = mlab.csv2rec(histogram)

      # Read the number of tasks per trace
      trace = config['trace']
      header = subprocess.Popen(["head", "-n1", trace], shell=False, stdout=subprocess.PIPE).communicate()[0]
      num_tasks = float(header.split("(")[2].split(":")[2])
      TasksPerFrame.append(num_tasks)
      print num_tasks

    
    self.FocusOnFrame   = 1
    self.FocusOnCluster = FirstCluster
    self.FocusOnMetric  = Metrics[self.FocusOnFrame][0]
    
    LastCluster         = np.max( Data[self.FocusOnFrame][CLUSTER_ID] )
    NumberOfClusters    = LastCluster - FirstCluster + 1


#   def ComputePlots(self):

#     self.ComputeScatter()

#     for frame in range(1, NumberOfFrames+1):
#       for cluster_id in range(FirstCluster, LastCluster+1):
#         ClusterData = Data[frame][Data[frame]['clusterid'] == cluster_id]
#         if (len(ClusterData) == 0): continue

#         #
#         # Compute the convex hull for this cluster
#         #
#         cluster_hull = ch.convexHull( ClusterData[[ DIM_X, DIM_Y ]] )
#         vertices = []
#         for v in cluster_hull:
#           vertices.append([v[0], v[1]])
#         cluster_hull = Polygon(vertices, True, color=PRVColor(cluster_id), zorder=1)
#         self.Hulls[(cluster_id,frame)] = cluster_hull

#         #
#         # Compute the centroid for this cluster
#         #
#         xdata = ClusterData[DIM_X]
#         ydata = ClusterData[DIM_Y]
#         if (len(xdata)>0 and len(ydata)>0):
#           centroid_x = np.average(xdata)
#           centroid_y = np.average(ydata)
#           cluster_centroid = self.AxesL.scatter(centroid_x, centroid_y, s=50, color=PRVColor(cluster_id), edgecolor="black", marker="o", zorder=3)
#           self.Centroids[(cluster_id,frame)] = cluster_centroid
        
#           # Save the trajectory for each cluster
#           self.Trajectories[(cluster_id, frame)] = (centroid_x, centroid_y)

#     # Compute the arrows for the trajectories
#     for cluster_id in range(FirstCluster, LastCluster+1):

#       from_frame = 1
#       to_frame = from_frame + 1
#       while (to_frame <= NumberOfFrames):
#         tail = (cluster_id, from_frame)
#         head = (cluster_id, to_frame)        
      
#         if not tail in self.Trajectories:
#           from_frame = to_frame
#           to_frame = from_frame +1
#           continue
#         else:
#           if not head in self.Trajectories:
#             to_frame = to_frame + 1
#             continue

#         from_x = self.Trajectories[tail][0]
#         from_y = self.Trajectories[tail][1]
#         to_x = self.Trajectories[head][0]
#         to_y = self.Trajectories[head][1]

#         if (not (math.isnan(from_x) or math.isnan(from_y) or math.isnan(to_x) or math.isnan(to_y))):
#           arrow = FancyArrowPatch((from_x,from_y), (to_x,to_y), arrowstyle='-|>', mutation_scale=20, color=PRVColor(cluster_id), linewidth=1)
#           self.Arrows[cluster_id].append(arrow)

#         from_frame = to_frame
#         to_frame = from_frame +1

#     # Compute the interpolated trajectory
#     self.AnimationSeconds = 5.0
#     self.AnimationSamples = 100
#     self.AnimationPeriod  = (self.AnimationSeconds / self.AnimationSamples)
#     self.T = np.linspace(0, NumberOfFrames, self.AnimationSamples)

#     for cluster_id in range(FirstCluster, LastCluster+1):
#       Xs = []
#       Ys = []
#       for frame in range(1, NumberOfFrames+1):
#         # Sequence of X and Y coords for this object 
#         if (cluster_id, frame) in self.Trajectories:
#           Xs.append( self.Trajectories[(cluster_id, frame)][0] )
#           Ys.append( self.Trajectories[(cluster_id, frame)][1] )

#       if (len(Xs) > 1 and len(Ys) > 1):

#         Ts = np.linspace(0, len(Xs), len(Xs))
  
#         fx = interp1d(Ts, Xs, kind="linear")
#         fy = interp1d(Ts, Ys, kind="linear")

#         # Generate the interpolated array
#         self.Xi[cluster_id] = fx(self.T)
#         self.Yi[cluster_id] = fy(self.T)
       
#         # Artists for the interpolated path
#         Path = Line2D([], [], color='black')
#         Tail = Line2D([], [], color='red', linewidth=3)
#         Head = Line2D([], [], color='red', marker='o', markeredgecolor='black')
#         self.Paths[cluster_id] = (Path, Tail, Head)
#         self.AxesL.add_line(Path)
#         self.AxesL.add_line(Tail)
#         self.AxesL.add_line(Head)

#   def DrawSingleFrame(self, frame, clear=True):
#      if (clear == True):
#        self.AxesL.clear()

#      print X_min_global, X_max_global, Y_min_global, Y_max_global, Z_min_global, Z_max_global

#      if not np.isnan(X_min_global) and not np.isnan(X_max_global):
#        self.AxesL.set_xlim(X_min_global, X_max_global)
#      if not np.isnan(Y_min_global) and not np.isnan(Y_max_global):
#        self.AxesL.set_ylim(Y_min_global, Y_max_global)
#      if (self.in_3D() == True):
#        if not np.isnan(Z_min_global) and not np.isnan(Z_max_global):
#          self.AxesL.set_zlim(Z_min_global, Z_max_global)

#      if (self.ToolbarL.GetToolState(self.ToolbarL.ON_CENTROID_CHECK) == True):
#        for cluster_id, f in self.Centroids:
#          if (self.DisplayingClusters[cluster_id] == True) and (frame == f):
#            centroid = self.Centroids[(cluster_id,frame)]
#            self.AxesL.add_artist(centroid)

#      if (self.ToolbarL.GetToolState(self.ToolbarL.ON_SCATTER_CHECK) == True):
#        for cluster_id, f in self.Scatters:
#          if (self.DisplayingClusters[cluster_id] == True) and (frame == f):
#            scatter = self.Scatters[(cluster_id,frame)]
#            if (self.in_3D()):
#              self.AxesL.add_collection3d(scatter)  
#            else:
#              self.AxesL.add_collection(scatter)

#      if (self.ToolbarL.GetToolState(self.ToolbarL.ON_HULL_CHECK) == True):
#        for cluster_id, f in self.Hulls:
#          if (self.DisplayingClusters[cluster_id] == True) and (frame == f):
#            hull = self.Hulls[(cluster_id,frame)]
#            if (hull):
#              self.AxesL.add_artist(hull)

#      self.AxesL.set_xlabel( self.XAxisCombo.GetValue() )
#      self.AxesL.set_ylabel( self.YAxisCombo.GetValue() )
#      if (self.in_3D() == True):
#        self.AxesL.set_zlabel( self.ZAxisCombo.GetValue() )

# #     self.CanvasL.draw()
  
#   def DrawAllFrames(self):
#     global NumberOfFrames

#     for frame in range(1, NumberOfFrames+1):
#       self.DrawSingleFrame(frame, False)

#   def DrawTrajectories(self):
#     for cluster_id in range(FirstCluster, LastCluster+1):
#       if (self.DisplayingClusters[cluster_id] == True):
#         for arrow in self.Arrows[cluster_id]:
#           self.AxesL.add_patch(arrow) 
# #    self.CanvasL.draw()


#   def PlotAll(self):
#     self.PlotL()
#     self.PlotR()

#   def PlotL(self):
#     self.AxesL.clear()

#     if (self.CurrentView == VIEW_FRAMES):
#       if (self.in_3D() == True):
#         self.AxesL = self.FigL.add_subplot(111, projection='3d')
#       else:
#         self.AxesL = self.FigL.add_subplot(111)

#       self.DrawSingleFrame(self.FocusOnFrame)

#     elif (self.CurrentView == VIEW_TRAJECTORY):
#       self.AxesL = self.FigL.add_subplot(111)

#       self.AxesL.set_title('Clusters trajectories')
#       self.DrawTrajectories()
#       self.DrawAllFrames()

#     self.FigL.tight_layout()
#     self.DrawL()

#   def PlotR(self):
#     self.CleanR()
#     self.AxesR1 = self.FigR.add_subplot(221)
#     self.AxesR2 = self.FigR.add_subplot(222)
#     self.AxesR3 = self.FigR.add_subplot(223)
#     self.AxesR4 = self.FigR.add_subplot(224)

#     self.PlotCorrelation()
#     self.PlotDispersion()
#     self.PlotHeatMap()
#     self.PlotCallers()
#     self.FigR.tight_layout()

#     self.DrawR()
 
#   def PlotCorrelation(self):
#     global metrics_list

#     for metric in metrics_list:
#       if (self.DisplayingMetrics[metric] == True):
#         metric_min = -1
#         metric_max = -1
#         avg_max    = -1
#         metric_y   = [ ]
#         for frame in range(1, NumberOfFrames+1):
#           frame_min = np.min( Data[frame][metric][Data[frame]['clusterid'] == self.FocusOnCluster] )
#           if ((frame_min < metric_min) or (metric_min == -1)):
#             metric_min = frame_min
    
#           frame_max = np.max( Data[frame][metric][Data[frame]['clusterid'] == self.FocusOnCluster] )
#           if ((frame_max > metric_max) or (metric_max == -1)):
#             metric_max = frame_max

#         for frame in range(1, NumberOfFrames+1):
#           frame_avg = np.average(Data[frame][metric][Data[frame]['clusterid'] == self.FocusOnCluster] )
#           if ((frame_avg > avg_max) or (avg_max == -1)):
#             avg_max = frame_avg

#         for frame in range(1, NumberOfFrames+1):
#           frame_avg = np.average(Data[frame][metric][Data[frame]['clusterid'] == self.FocusOnCluster] )
# #          normalized_frame_avg = (frame_avg - metric_min) / (metric_max - metric_min)
# #          normalized_frame_avg = (frame_avg / metric_max)
#           normalized_frame_avg = (frame_avg / avg_max)
#           metric_y.append( normalized_frame_avg )

#         if (metric.lower() == self.FocusOnMetric.lower()):
#           line_size = 3
#         else:
#           line_size = 1
#         self.AxesR2.plot (range(1, NumberOfFrames+1), metric_y, label=metric, lw=line_size, color=MetricColor(metric) )

#     self.AxesR2.set_title('Metrics correlation for Region '+str(ClusterOffset(self.FocusOnCluster)))
#     self.AxesR2.set_xticks(range(1, NumberOfFrames+1))
# #    if (self.ToolbarR.GetToolState(self.ToolbarR.ON_LEGEND_CHECK) == True):
# #      self.AxesR2.legend(map(lambda x:x.upper(), metrics_list), loc=(0,0), prop={'size':7})

    
#   def PlotHeatMap(self):
#     heatm_precision = self.Bins
#     heatm_num_ticks = 5

#     heatm_x = Data[self.FocusOnFrame][DIM_X][Data[self.FocusOnFrame]['clusterid'] == self.FocusOnCluster]
#     heatm_y = Data[self.FocusOnFrame][DIM_Y][Data[self.FocusOnFrame]['clusterid'] == self.FocusOnCluster]

#     self.AxesR1.set_title('Support for Region '+str(ClusterOffset(self.FocusOnCluster)))

#     heatmap, heatm_yedges, heatm_xedges = np.histogram2d(heatm_y, heatm_x, bins=heatm_precision)

#     if (self.ToolbarR.GetToolState(self.ToolbarR.ON_INTERPOLATE_CHECK) == True):
#       cax = self.AxesR1.imshow(heatmap, origin='lower', aspect='auto', extent=(heatm_xedges.min(), heatm_xedges.max(), heatm_yedges.min(), heatm_yedges.max()))
#     else:
#       cax = self.AxesR1.imshow(heatmap, interpolation='nearest', origin='lower', aspect='auto', extent=(heatm_xedges.min(), heatm_xedges.max(), heatm_yedges.min(), heatm_yedges.max()))

#     self.ColorBar = self.FigR.colorbar(cax, ax=self.AxesR1, orientation='vertical', use_gridspec=True, shrink=0.8)
    

#   def PlotDispersion(self):
#     metric_dispersion = [ ]
#     metric_average    = [ ]
#     metric_min        = [ ]
#     metric_max        = [ ]
#     for frame in range(1, NumberOfFrames+1):
#       frame_dispersion = Data[frame][self.FocusOnMetric][Data[frame]['clusterid'] == self.FocusOnCluster]
#       metric_dispersion.append( frame_dispersion )
#       metric_average.append( np.average(Data[frame][self.FocusOnMetric][Data[frame]['clusterid'] == self.FocusOnCluster]) )
#       metric_min.append( np.min(Data[frame][self.FocusOnMetric][Data[frame]['clusterid'] == self.FocusOnCluster]) )
#       metric_max.append( np.max(Data[frame][self.FocusOnMetric][Data[frame]['clusterid'] == self.FocusOnCluster]) )
  
#     self.AxesR4.set_title(self.FocusOnMetric.upper()+' for Region '+str(ClusterOffset(self.FocusOnCluster)))
#     if (self.ToolbarR.GetToolState(self.ToolbarR.ON_BOXPLOT_CHECK) == True):
#       self.AxesR4.boxplot(metric_dispersion)
#       self.AxesR4.plot( range(1, NumberOfFrames+1), metric_average, lw=2, color=MetricColor(self.FocusOnMetric) )
#     else:
#       x = range(1, NumberOfFrames+1)
#       self.AxesR4.plot(x, metric_min, ls='--', color=MetricColor(self.FocusOnMetric))
#       self.AxesR4.plot(x, metric_average, marker='o', ms=2, color=MetricColor(self.FocusOnMetric))
#       self.AxesR4.plot(x, metric_max, ls='--', color=MetricColor(self.FocusOnMetric))
#       self.AxesR4.fill_between(x, metric_min, metric_max, alpha=0.25, color=MetricColor(self.FocusOnMetric) )
#       self.AxesR4.set_xticks(range(1, NumberOfFrames+1))
#       self.AxesR4.set_xlim(1, NumberOfFrames)
#       self.AxesR4.set_xbound(1, NumberOfFrames)

#     if (self.GetFittingSamples() > 0):
#       fit_x, fit_y = self.Predict(metric_average)
#       self.AxesR4.plot(fit_x, fit_y, ls=':', color='black', marker='o', ms=4)
#       self.AxesR4.set_xticks(range(1, len(fit_x)+1))
#       self.AxesR4.set_xlim(1, len(fit_x))
#       self.AxesR4.set_xbound(1, len(fit_x))

#   def Predict(self, y):
#     x = range(1, len(y)+1)
   
#     fit = np.polyfit(x, y, self.GetFittingDegree())
#     fit_fn = np.poly1d(fit) # fit_fn is now a function which takes in x and returns an estimate for y

#     fit_x = range(1, self.GetFittingSamples() + 1)
#     fit_y = [ ]
#     for x in fit_x:
#       fit_y.append( fit_fn(x) )

#     return fit_x, fit_y

#   def GetFittingSamples(self):
#     return int(self.PredictExperiments.GetValue())

#   def GetFittingDegree(self):
#     return self.RegressionTypeCombo.GetSelection() + 1

#   def PlotCallers(self):
#     try: 
#       Callers[self.FocusOnFrame]
#     except: 
#       return

#     if (len(Callers[self.FocusOnFrame]) > 0):
#       callers_labels = Callers[self.FocusOnFrame]['caller'][Callers[self.FocusOnFrame]['clusterid'] == self.FocusOnCluster]
#       callers_fracts = Callers[self.FocusOnFrame]['pct'][Callers[self.FocusOnFrame]['clusterid'] == self.FocusOnCluster]
#       self.AxesR3.set_title('Callers distribution for Region '+str(ClusterOffset(self.FocusOnCluster)))
#       self.AxesR3.pie(callers_fracts, autopct='%1.1f%%', shadow=True) #labels=callers_labels
#       self.AxesR3.set_aspect('equal')
#       if (self.ToolbarR.GetToolState(self.ToolbarR.ON_LEGEND_CHECK) == True):
#         self.AxesR3.legend( callers_labels, loc=(0,0), prop={'size':7} )

  # def on_Frame_Change(self, event):
  #   self.FocusOnFrame = self.FrameSlider.GetValue()
  #   self.PlotL()
  #   self.PlotR()

  # def on_Resolution_Change(self, event):
  #   self.Bins = self.ResolutionSlider.GetValue()
  #   self.PlotR()

  def PlotL(self):
    self.AxesL.clear()
    if (self.in_3D() == True):
      self.AxesL = self.FigL.add_subplot(111, projection='3d')
    else:
      self.AxesL = self.FigL.add_subplot(111)

    self.Compute_Scatters()
    self.Compute_Ranges()
    self.Set_Scales()

    self.Display_Objects( True )
    self.CanvasL.draw()

  def Compute_Ranges(self):
    dim_x = self.XAxisCombo.GetValue()
    dim_y = self.YAxisCombo.GetValue()
    if (self.in_3D() == True):
      dim_z = self.ZAxisCombo.GetValue()

    X_local_min = []
    X_local_max = []
    Y_local_min = []
    Y_local_max = []
    Z_local_min = []
    Z_local_max = []

    for frame in range(1, NumberOfFrames+1):
      X_local_min.append( np.nanmin(Data[frame][dim_x]) )
      X_local_max.append( np.nanmax(Data[frame][dim_x]) )
      Y_local_min.append( np.nanmin(Data[frame][dim_y]) )
      Y_local_max.append( np.nanmax(Data[frame][dim_y]) )
      if self.in_3D():
        Z_local_min.append( np.nanmin(Data[frame][dim_z]) )
        Z_local_max.append( np.nanmax(Data[frame][dim_z]) )

    X_local_min_scaled = np.array(X_local_min) * np.array(TasksPerFrame)
    X_local_max_scaled = np.array(X_local_max) * np.array(TasksPerFrame)
    FrameWithMinX = X_local_min_scaled.argmin() 
    FrameWithMaxX = X_local_max_scaled.argmax() 
    Y_local_min_scaled = np.array(Y_local_min) * np.array(TasksPerFrame)
    Y_local_max_scaled = np.array(Y_local_max) * np.array(TasksPerFrame)
    FrameWithMinY = Y_local_min_scaled.argmin() 
    FrameWithMaxY = Y_local_max_scaled.argmax() 

    print TasksPerFrame
    print X_local_min, X_local_max
    print Y_local_min, Y_local_max
    print X_local_min_scaled, X_local_max_scaled
    print Y_local_min_scaled, Y_local_max_scaled
    print FrameWithMinX, FrameWithMaxX, 
    print FrameWithMinY, FrameWithMaxY

    if self.in_3D():
      Z_local_min_scaled = np.array(Z_local_min) * np.array(TasksPerFrame)
      Z_local_max_scaled = np.array(Z_local_max) * np.array(TasksPerFrame)
      FrameWithMinZ = Z_local_min_scaled.argmin() 
      FrameWithMaxZ = Z_local_max_scaled.argmax() 

    XMinRatioPerFrame = []
    YMinRatioPerFrame = []
    ZMinRatioPerFrame = []

    XMaxRatioPerFrame = []
    YMaxRatioPerFrame = []
    ZMaxRatioPerFrame = []
    for frame in range(1, NumberOfFrames+1):

      ### Compute the ratios for the current trace with respect to the min/max values for this dimension
      XMinRatioPerFrame.append( TasksPerFrame[ FrameWithMinX ] / TasksPerFrame[ frame-1 ] )
      YMinRatioPerFrame.append( TasksPerFrame[ FrameWithMinY ] / TasksPerFrame[ frame-1 ] )
      if self.in_3D():
        ZMinRatioPerFrame.append( TasksPerFrame[ FrameWithMinZ ] / TasksPerFrame[ frame-1 ] )

      XMaxRatioPerFrame.append( TasksPerFrame[ FrameWithMaxX ] / TasksPerFrame[ frame-1 ] )
      YMaxRatioPerFrame.append( TasksPerFrame[ FrameWithMaxY ] / TasksPerFrame[ frame-1 ] )
      if self.in_3D():
        ZMaxRatioPerFrame.append( TasksPerFrame[ FrameWithMaxZ ] / TasksPerFrame[ frame-1 ] )

      ### Normalize the mins/maxs per trace with respect to the ratios
      self.XRangeScaled[frame] = ( X_local_min[ FrameWithMinX ] * XMinRatioPerFrame[frame-1], X_local_max[ FrameWithMaxX ] * XMaxRatioPerFrame[frame-1] )
      self.YRangeScaled[frame] = ( Y_local_min[ FrameWithMinY ] * YMinRatioPerFrame[frame-1], Y_local_max[ FrameWithMaxY ] * YMaxRatioPerFrame[frame-1] )
      if self.in_3D():
        self.ZRangeScaled[frame] = ( Z_local_min[ FrameWithMinZ ] * ZMinRatioPerFrame[frame-1], Z_local_max[ FrameWithMaxZ ] * ZMaxRatioPerFrame[frame-1] )

      ### Store the global ranges
      self.XRange[frame] = ( np.min( X_local_min ), np.max( X_local_max ) )
      self.YRange[frame] = ( np.min( Y_local_min ), np.max( Y_local_max ) )
      if self.in_3D():
        self.ZRange[frame] = ( np.min( Z_local_min ), np.max( Z_local_max ) )
      else:
        self.ZRange[frame] = (0, 0)

    for frame in range(1, NumberOfFrames+1):
      print frame, dim_x, "(", self.XRange[frame][0], ",", self.XRange[frame][1], ") (", self.XRangeScaled[frame][0], ",", self.XRangeScaled[frame][1], ")"
      print frame, dim_y, "(", self.YRange[frame][0], ",", self.YRange[frame][1], ") (", self.YRangeScaled[frame][0], ",", self.YRangeScaled[frame][1], ")"
      if self.in_3D():
        print frame, dim_z, "(", self.ZRange[frame][0], ",", self.ZRange[frame][1], ") (", self.ZRangeScaled[frame][0], ",", self.ZRangeScaled[frame][1], ")"

  def Set_Scales(self):

    print self.AxesL.get_xlim()
    print self.AxesL.get_ylim()

    if (self.ScaleState[X] == True):
      self.AxesL.set_xlim( self.XRangeScaled[self.FocusOnFrame][0], self.XRangeScaled[self.FocusOnFrame][1] )
    else:
      self.AxesL.set_xlim( self.XRange[self.FocusOnFrame][0], self.XRange[self.FocusOnFrame][1] )

    if (self.ScaleState[Y] == True):
      self.AxesL.set_ylim( self.YRangeScaled[self.FocusOnFrame][0], self.YRangeScaled[self.FocusOnFrame][1] )
    else:
      self.AxesL.set_ylim( self.YRange[self.FocusOnFrame][0], self.YRange[self.FocusOnFrame][1] )
  
    if self.in_3D():
      if (self.ScaleState[Z] == True):
        self.AxesL.set_zlim( self.ZRangeScaled[self.FocusOnFrame][0], self.ZRangeScaled[self.FocusOnFrame][1] )
      else:
        self.AxesL.set_zlim( self.ZRange[self.FocusOnFrame][0], self.ZRange[self.FocusOnFrame][1] )

    if self.in_2D():
      if (self.LogState[X] == True):
        self.AxesL.set_xscale('log')
      else:
        self.AxesL.set_xscale('linear')
      if (self.LogState[Y] == True):
        self.AxesL.set_yscale('log')
      else:
        self.AxesL.set_yscale('linear')
    else:
      if (self.LogState[X] == True):
        self.AxesL.xaxis.set_scale('log')
      else:
        self.AxesL.xaxis.set_scale('linear')
      if (self.LogState[Y] == True):
        self.AxesL.yaxis.set_scale('log')
      else:
        self.AxesL.yaxis.set_scale('linear')
      if (self.LogState[Z] == True) and (self.in_3D()):
        self.AxesL.zaxis.set_scale('log')
      else:
        self.AxesL.zaxis.set_scale('linear')

  def Compute_Scatters(self):

    self.Scatters.clear()

    dim_x = self.XAxisCombo.GetValue()
    dim_y = self.YAxisCombo.GetValue()
    dim_z = self.ZAxisCombo.GetValue()

    for frame in range(1, NumberOfFrames+1):
      for cluster_id in range(FirstCluster, LastCluster+1):
        ClusterData = Data[frame][Data[frame][CLUSTER_ID] == cluster_id]
        if (len(ClusterData) == 0): continue

        #
        # Compute the scatter plot for this cluster
        #
        if self.in_3D():
          cluster_scatter = self.AxesL.scatter(
            ClusterData[dim_x], 
            ClusterData[dim_y], 
            ClusterData[dim_z], 
            color=PRVColor(cluster_id), marker=".", zorder=2)
          cluster_scatter.set_visible(False)
          self.Scatters[(cluster_id, frame)] = cluster_scatter
        else:
          cluster_scatter = self.AxesL.scatter(
            ClusterData[dim_x], 
            ClusterData[dim_y],
            color=PRVColor(cluster_id), marker=".", zorder=2)
          cluster_scatter.set_visible(False)
          self.Scatters[(cluster_id, frame)] = cluster_scatter

        # 
        # Compute the centroid for this cluster
        # 
        centroid_x = nanmean( ClusterData[dim_x] )
        centroid_y = nanmean( ClusterData[dim_y] )
        if self.in_3D():
          centroid_z = nanmean( ClusterData[dim_z] )
          cluster_centroid = self.AxesL.scatter(centroid_x, centroid_y, centroid_z, s=50, color=PRVColor(cluster_id), edgecolor="black", marker="o", zorder=3)
          self.Centroids[(cluster_id, frame)] = cluster_centroid
          # Save each cluster's trajectory
          self.Trajectories[(cluster_id, frame)] = (centroid_x, centroid_y, centroid_z)
        else:
          cluster_centroid = self.AxesL.scatter(centroid_x, centroid_y, s=50, color=PRVColor(cluster_id), edgecolor="black", marker="o", zorder=3)
          self.Centroids[(cluster_id, frame)] = cluster_centroid
          # Save each cluster's trajectory
          self.Trajectories[(cluster_id, frame)] = (centroid_x, centroid_y)

        #
        # Compute the convex hull for this cluster
        #
#        if self.in_2D():
#          vertices = []
#          cluster_hull = ch.convexHull( ClusterData[[ str(dim_x), str(dim_y) ]] )
#          for point in cluster_hull:
#            vertices.append([point[X], point[Y]])
#          cluster_hull = Polygon(vertices, True, color=PRVColor(cluster_id), zorder=1)
#          self.AxesL.add_artist( cluster_hull )
#          self.Hulls[(cluster_id, frame)] = cluster_hull


    # Compute the arrows for the trajectories
    for cluster_id in range(FirstCluster, LastCluster+1):

      from_frame = 1
      to_frame   = from_frame + 1
      while (to_frame <= NumberOfFrames):
        tail = (cluster_id, from_frame)
        head = (cluster_id, to_frame)        
                
        if not tail in self.Trajectories:
          from_frame = to_frame
          to_frame = from_frame +1
          continue
        else:
          if not head in self.Trajectories:
            to_frame = to_frame + 1
            continue
        
        from_x = self.Trajectories[tail][0]
        from_y = self.Trajectories[tail][1]
        to_x   = self.Trajectories[head][0]
        to_y   = self.Trajectories[head][1]

        if (not (math.isnan(from_x) or math.isnan(from_y) or math.isnan(to_x) or math.isnan(to_y))):
          arrow = FancyArrowPatch((from_x,from_y), (to_x,to_y), arrowstyle='-|>', mutation_scale=20, color=PRVColor(cluster_id), linewidth=1)
          self.Arrows[cluster_id].append(arrow)
          self.AxesL.add_artist(arrow)

        from_frame = to_frame
        to_frame   = from_frame +1

          #     # Compute the interpolated trajectory
          #     self.AnimationSeconds = 5.0
          #     self.AnimationSamples = 100
          #     self.AnimationPeriod  = (self.AnimationSeconds / self.AnimationSamples)
          #     self.T = np.linspace(0, NumberOfFrames, self.AnimationSamples)

          #     for cluster_id in range(FirstCluster, LastCluster+1):
          #       Xs = []
          #       Ys = []
          #       for frame in range(1, NumberOfFrames+1):
          #         # Sequence of X and Y coords for this object 
          #         if (cluster_id, frame) in self.Trajectories:
          #           Xs.append( self.Trajectories[(cluster_id, frame)][0] )
          #           Ys.append( self.Trajectories[(cluster_id, frame)][1] )

          #       if (len(Xs) > 1 and len(Ys) > 1):

          #         Ts = np.linspace(0, len(Xs), len(Xs))
            
          #         fx = interp1d(Ts, Xs, kind="linear")
          #         fy = interp1d(Ts, Ys, kind="linear")

          #         # Generate the interpolated array
          #         self.Xi[cluster_id] = fx(self.T)
          #         self.Yi[cluster_id] = fy(self.T)
                 
          #         # Artists for the interpolated path
          #         Path = Line2D([], [], color='black')
          #         Tail = Line2D([], [], color='red', linewidth=3)
          #         Head = Line2D([], [], color='red', marker='o', markeredgecolor='black')
          #         self.Paths[cluster_id] = (Path, Tail, Head)
          #         self.AxesL.add_line(Path)
          #         self.AxesL.add_line(Tail)
          #         self.AxesL.add_line(Head)


  def Display_Scatters(self):
    for (cluster_id, frame) in self.Scatters:
      scatter = self.Scatters[(cluster_id, frame)]
      draw_this_frame = (self.CurrentView == VIEW_TRAJECTORY) or (frame == self.FocusOnFrame)
      if (self.ToolbarL.GetToolState(self.ToolbarL.ON_SCATTER_CHECK) == True) and (draw_this_frame):
          scatter.set_visible(True)
      else:
        scatter.set_visible(False)

  def Display_Centroids(self):
    for (cluster_id, frame) in self.Centroids:
      centroid = self.Centroids[(cluster_id, frame)]
      draw_this_frame = (self.CurrentView == VIEW_TRAJECTORY) or (frame == self.FocusOnFrame)
      if (self.ToolbarL.GetToolState(self.ToolbarL.ON_CENTROID_CHECK) == True) and (draw_this_frame):
          centroid.set_visible(True)
      else:
        centroid.set_visible(False)

  def Display_Hulls(self):
    for (cluster_id, frame) in self.Hulls:
      hull = self.Hulls[(cluster_id, frame)]
      draw_this_frame = (self.CurrentView == VIEW_TRAJECTORY) or (frame == self.FocusOnFrame)
      if (self.ToolbarL.GetToolState(self.ToolbarL.ON_HULL_CHECK) == True) and (draw_this_frame):
          hull.set_visible(True)
      else:
        hull.set_visible(False)

  def Hide_Objects(self, objects_to_hide):
    if (objects_to_hide == HIDE_SCATTERS) or (objects_to_hide == HIDE_ALL):
      for obj in self.Scatters:
        self.Scatters[obj].set_visible(False)
    if (objects_to_hide == HIDE_CENTROIDS) or (objects_to_hide == HIDE_ALL):
      for obj in self.Centroids:
        self.Centroids[obj].set_visible(False)
    if (objects_to_hide == HIDE_HULLS) or (objects_to_hide == HIDE_ALL):
      for obj in self.Hulls:
        self.Hulls[obj].set_visible(False)
    if (objects_to_hide == HIDE_ARROWS) or (objects_to_hide == HIDE_ALL):
      for obj in self.Arrows:
        for arrow in self.Arrows[obj]:
          arrow.set_visible(False)

  def Display_Objects(self, clean_previous_drawings):

    if clean_previous_drawings:
      self.Hide_Objects(HIDE_ALL)

    self.Display_Scatters()
    self.Display_Centroids()
    self.Display_Hulls()

    #
    # Configure axes labels
    # 
    self.AxesL.set_xlabel( self.XAxisCombo.GetValue() )
    self.AxesL.set_ylabel( self.YAxisCombo.GetValue() )
    if (self.in_3D() == True):
      self.AxesL.set_zlabel( self.ZAxisCombo.GetValue() )

 
  # def Draw_All_Frames(self):
  #   self.Hide_Objects(HIDE_ALL)

  #   for frame in range(1, NumberOfFrames+1):
  #     self.Draw_Frame(frame, False)

  def Display_Trajectories(self):
    for cluster_id in range(FirstCluster, LastCluster+1):
      if (self.DisplayingClusters[cluster_id] == True):
        for arrow in self.Arrows[cluster_id]:
          arrow.set_visible(True)


   # def SetupView(self):
  #   if (self.CurrentView == VIEW_FRAMES):
  #     self.ViewButton.SetLabel("Switch to "+VIEW_TRAJECTORY+" view")
  #     self.PrevButton.Enable()
  #     self.NextButton.Enable()
  #     self.FrameSlider.Enable()
  #     self.ResolutionSlider.Enable()
  #     self.PredictExperiments.Enable()
  #     self.RegressionTypeCombo.Enable()
  #     self.ToolbarL.ToggleTool(self.ToolbarL.ON_SCATTER_CHECK,  True)
  #     self.ToolbarL.ToggleTool(self.ToolbarL.ON_HULL_CHECK,     False)
  #     self.ToolbarL.ToggleTool(self.ToolbarL.ON_CENTROID_CHECK, False)
  #   elif (self.CurrentView == VIEW_TRAJECTORY):
  #     self.ViewButton.SetLabel("Switch to "+VIEW_FRAMES+" view")
  #     self.PrevButton.Disable()
  #     self.NextButton.Disable()
  #     self.FrameSlider.Disable()
  #     self.ResolutionSlider.Disable()
  #     self.PredictExperiments.Disable()
  #     self.RegressionTypeCombo.Disable()
  #     self.ToolbarL.ToggleTool(self.ToolbarL.ON_SCATTER_CHECK,  False)
  #     self.ToolbarL.ToggleTool(self.ToolbarL.ON_HULL_CHECK,     False)
  #     self.ToolbarL.ToggleTool(self.ToolbarL.ON_CENTROID_CHECK, True)
  #   self.ViewButton.Enable()
  #   self.PlayButton.Enable()
  #   self.ClustersScroll.Enable()
  #   self.MetricsScroll.Enable()

  # def DisableControls(self):
  #   self.ViewButton.Disable()
  #   self.PrevButton.Disable()
  #   self.NextButton.Disable()
  #   self.PlayButton.Disable()
  #   self.FrameSlider.Disable()
  #   self.ClustersScroll.Disable()
  #   self.MetricsScroll.Disable()

  # def on_View_Button(self, event):
  #   if (self.ViewButton.GetValue() == True):
  #     self.CurrentView = VIEW_TRAJECTORY
  #   else:
  #     self.CurrentView = VIEW_FRAMES
  #   self.SetupView()
  #   self.PlotL()

  # def on_Playing_Timer(self, event):
  #   global NumberOfFrames

  #   self.FocusOnFrame = self.PlayingCurrentFrame
  #   self.FrameSlider.SetValue(self.PlayingCurrentFrame)
  #   self.PlotL()
  #   self.PlotR()
  #   self.PlayingCurrentFrame = self.PlayingCurrentFrame + 1
  #   if (self.PlayingCurrentFrame > NumberOfFrames):
  #     self.PlayTimer.Stop()
  #     self.SetupView()

  # def on_Play_Button(self, event):
  #   self.DisableControls()
  #   if (self.CurrentView == VIEW_FRAMES):
  #     self.PlayingCurrentFrame = 1
  #     self.PlayTimer.Start(1000)
  #   elif (self.CurrentView == VIEW_TRAJECTORY):
  #     animation.TimedAnimation.__init__(self, self.FigL, interval=self.AnimationPeriod, repeat=False, blit=True)

  # def on_Prev_Button(self, event):
  #   slider_old_value = self.FrameSlider.GetValue()
  #   slider_new_value = slider_old_value - 1
  #   if (slider_new_value >= 1):
  #     self.FrameSlider.SetValue(slider_new_value)
  #     self.FocusOnFrame = slider_new_value
  #     self.PlotL()
  #     self.PlotR()

  # def on_Next_Button(self, event):
  #   global NumberOfFrames

  #   slider_old_value = self.FrameSlider.GetValue()
  #   slider_new_value = slider_old_value + 1
  #   if (slider_new_value <= NumberOfFrames):
  #     self.FrameSlider.SetValue(slider_new_value)
  #     self.FocusOnFrame = slider_new_value
      
  #     self.PlotL()
  #     self.PlotR()

#  def on_Metrics_Display(self, event):
#    btn = event.GetEventObject()
#    metric = btn.GetName()
#    if (self.DisplayingMetrics[ metric ] == True):
#      self.DisplayingMetrics[ metric ] = False
#      bmp = self.bmp_nodisplay
#    else:
#      self.DisplayingMetrics[ metric ] = True
#      bmp = self.bmp_display
#
#    for controls in self.MetricsScrollList:
#      if (controls[0].GetName() == metric):
#        controls[0].SetBitmapLabel(bmp)
#        break
#  #   self.PlotR()
#
#  def on_Metrics_Focus(self, event):
#
#    btn = event.GetEventObject()
#    self.set_Metric_Focus( btn.GetName() )
#    self.PlotR()
#
#  def set_Metric_Focus(self, metric):
#    for controls in self.MetricsScrollList:
#      if (controls[1].GetName() == metric):
#        controls[1].SetValue(1)
#        controls[1].SetBackgroundColour(wx.Colour(Color_Selected[0]*255, Color_Selected[1]*255, Color_Selected[2]*255, 0))
#        self.FocusOnMetric = metric
#      else:
#        controls[1].SetValue(0)
#        controls[1].SetBackgroundColour(wx.Colour(Color_NonSelected[0]*255, Color_NonSelected[1]*255, Color_NonSelected[2]*255, 0))
#
#  def on_Clusters_Display(self, event):
#    btn = event.GetEventObject()
#    cluster_id = int(btn.GetName())
#    if (self.DisplayingClusters[ cluster_id ] == True):
#      self.DisplayingClusters[ cluster_id ] = False
#      bmp = self.bmp_nodisplay
#    else:
#      self.DisplayingClusters[ cluster_id ] = True
#      bmp = self.bmp_display
#
#    for controls in self.ClustersScrollList:
#      if (int(controls[0].GetName()) == cluster_id):
#        controls[0].SetBitmapLabel(bmp)
#        break
#  #   self.PlotL()
#
#  def on_Clusters_Focus(self, event):
#    btn = event.GetEventObject()
#    self.set_Cluster_Focus(btn.GetName())
#  #   self.PlotR()
#
#  def set_Cluster_Focus(self, cluster_id):
#    for controls in self.ClustersScrollList:
#      if (controls[1].GetName() == str(cluster_id)):
#        controls[1].SetValue(1)
#        controls[1].SetBackgroundColour(wx.Colour(Color_Selected[0]*255, Color_Selected[1]*255, Color_Selected[2]*255, 0))
#        self.FocusOnCluster = int(cluster_id)
#      else:
#        controls[1].SetValue(0)
#        controls[1].SetBackgroundColour(wx.Colour(Color_NonSelected[0]*255, Color_NonSelected[1]*255, Color_NonSelected[2]*255, 0))

  # def CleanL(self):
  #   self.FigL.clf()

  # def CleanR(self):
  #   self.FigR.clf()

  # def CleanAll(self):
  #   self.CleanL()
  #   self.CleanR()

  # def DrawL(self):
  #   self.CanvasL.draw()
  
  # def DrawR(self):
  #   self.CanvasR.draw()
  
  # def DrawAll(self):
  #   self.DrawL()
  #   self.DrawR()

  # def on_Prediction_Change(self, event):
  #   self.PlotR()

  # def on_RegressionType_Change(self, event):
  #   if (self.GetFittingSamples() > 0):
  #     self.PlotR()


  # def _draw_frame(self, current_frame):
  #   i = current_frame
  #   head = i - 1
  #   head_len = 0.5

  #   for cluster_id in self.Paths:
  #     if (self.DisplayingClusters[cluster_id] == True):
  #       x = self.Xi[cluster_id]
  #       y = self.Yi[cluster_id]

  #       Path = self.Paths[cluster_id][0]
  #       Tail = self.Paths[cluster_id][1]
  #       Head = self.Paths[cluster_id][2]

  #       # Status of this frame for each object
  #       head_slice = (self.T > self.T[i] - head_len) & (self.T < self.T[i])
  #       Path.set_data(x[:i], y[:i])
  #       Tail.set_data(x[head_slice], y[head_slice])
  #       Head.set_data(x[head], y[head])

  #       # Display the trajectory animation
  #       self._drawn_artists.append(Path)
  #       self._drawn_artists.append(Tail)
  #       self._drawn_artists.append(Head)
    
  #   if (current_frame+1 == self.AnimationSamples):
  #     self.SetupView()

  # def new_frame_seq(self):
  #   return iter(range(self.AnimationSamples))

  # def _init_draw(self):
  #   for cluster_id in self.Paths:
  #     lines =  [self.Paths[cluster_id][0], self.Paths[cluster_id][1], self.Paths[cluster_id][2]]
  #     for l in lines:
  #         l.set_data([], [])

  def in_3D(self):
    return self.Activate3DButton.GetValue()

  def in_2D(self):
    return not self.in_3D()

  #
  # Triggers
  # 
  def on_XAxisCombo_Change(self, event):
    self.PlotL()

  def on_YAxisCombo_Change(self, event):
    self.PlotL()

  def on_ZAxisCombo_Change(self, event):
    self.PlotL()

  def on_Swap_Button(self, event):
    old_x = self.XAxisCombo.GetSelection()
    old_y = self.YAxisCombo.GetSelection()
    old_log_x = self.LogState[X]
    old_log_y = self.LogState[Y]
    self.XAxisCombo.SetSelection( old_y )
    self.YAxisCombo.SetSelection( old_x )
    if (old_log_x == 1):
      self.YAxisLogButton.SetBitmapLabel(self.bmp_log_on)
    else:
      self.YAxisLogButton.SetBitmapLabel(self.bmp_log_off)
    if (old_log_y == 1):
      self.XAxisLogButton.SetBitmapLabel(self.bmp_log_on)
    else:
      self.XAxisLogButton.SetBitmapLabel(self.bmp_log_off)
    self.LogState[X] = old_log_y
    self.LogState[Y] = old_log_x
    self.PlotL()

  def on_3D_Button(self, event):
    if (self.Activate3DButton.GetValue() == True):
      self.ZAxisCombo.Enable()
      self.ZAxisLogButton.Enable()
      self.ZAxisScaleButton.Enable()
      self.ToolbarL.EnableTool(self.ToolbarL.ON_HULL_CHECK, False)
    else:
      self.ZAxisCombo.Disable()
      self.ZAxisLogButton.Disable()
      self.ZAxisScaleButton.Disable()
      self.ToolbarL.EnableTool(self.ToolbarL.ON_HULL_CHECK, True)
    self.PlotL()

  def on_XLog_Button(self, event):
    btn = event.GetEventObject()
    if (self.LogState[X] == 0):
      self.LogState[X] = 1
      btn.SetBitmapLabel(self.bmp_log_on)
    else:
      self.LogState[X] = 0
      btn.SetBitmapLabel(self.bmp_log_off)
    self.Set_Scales()
    self.CanvasL.draw()
    
  def on_YLog_Button(self, event):
    btn = event.GetEventObject()
    if (self.LogState[Y] == 0):
      self.LogState[Y] = 1
      btn.SetBitmapLabel(self.bmp_log_on)
    else:
      self.LogState[Y] = 0
      btn.SetBitmapLabel(self.bmp_log_off)
    self.Set_Scales()
    self.CanvasL.draw()

  def on_ZLog_Button(self, event):
    btn = event.GetEventObject()
    if (self.LogState[Z] == 0):
      self.LogState[Z] = 1
      btn.SetBitmapLabel(self.bmp_log_on)
    else:
      self.LogState[Z] = 0
      btn.SetBitmapLabel(self.bmp_log_off)
    self.Set_Scales()
    self.CanvasL.draw()

  def on_XScale_Button(self, event):
    btn = event.GetEventObject()
    if (self.ScaleState[X] == 0):
      self.ScaleState[X] = 1
      btn.SetBitmapLabel(self.bmp_log_on)
    else:
      self.ScaleState[X] = 0
      btn.SetBitmapLabel(self.bmp_log_off)
    self.Set_Scales()
    self.CanvasL.draw()

  def on_YScale_Button(self, event):
    btn = event.GetEventObject()
    if (self.ScaleState[Y] == 0):
      self.ScaleState[Y] = 1
      btn.SetBitmapLabel(self.bmp_log_on)
    else:
      self.ScaleState[Y] = 0
      btn.SetBitmapLabel(self.bmp_log_off)
    self.Set_Scales()
    self.CanvasL.draw()

  def on_ZScale_Button(self, event):
    btn = event.GetEventObject()
    if (self.ScaleState[Z] == 0):
      self.ScaleState[Z] = 1
      btn.SetBitmapLabel(self.bmp_log_on)
    else:
      self.ScaleState[Z] = 0
      btn.SetBitmapLabel(self.bmp_log_off)
    self.Set_Scales()
    self.CanvasL.draw()

  def on_Prev_Button(self, event):
    slider_old_value = self.FrameSlider.GetValue()
    slider_new_value = slider_old_value - 1
    if (slider_new_value >= 1):
      self.FrameSlider.SetValue(slider_new_value)
      self.FocusOnFrame = slider_new_value
      self.Display_Objects(True)    
      self.Set_Scales()
      self.CanvasL.draw()

  def on_Next_Button(self, event):
    slider_old_value = self.FrameSlider.GetValue()
    slider_new_value = slider_old_value + 1
    if (slider_new_value <= NumberOfFrames):
      self.FrameSlider.SetValue(slider_new_value)
      self.FocusOnFrame = slider_new_value
      self.Display_Objects(True)    
      self.Set_Scales()
      self.CanvasL.draw()
 
  def on_Play_Button(self, event):
    return

  def on_Frame_Change(self, event):
    self.FocusOnFrame = self.FrameSlider.GetValue()
    self.Display_Objects(True)
    self.Set_Scales()
    self.CanvasL.draw()

  def on_Trajectory_Button(self, event):
    if (self.CurrentView == VIEW_FRAMES):
      self.CurrentView = VIEW_TRAJECTORY
      self.PrevButton.Disable()
      self.NextButton.Disable()
      self.FrameSlider.Disable()

      self.PrevScaleState[X] = self.ScaleState[X]
      self.PrevScaleState[Y] = self.ScaleState[Y]
      self.PrevScaleState[Z] = self.ScaleState[Z]
      self.ScaleState[X] = 0
      self.ScaleState[Y] = 0
      self.ScaleState[Z] = 0

      self.XAxisScaleButton.Disable()
      self.YAxisScaleButton.Disable()
      self.ZAxisScaleButton.Disable()
      self.ToolbarL.ToggleTool(self.ToolbarL.ON_SCATTER_CHECK,  False)
      self.ToolbarL.ToggleTool(self.ToolbarL.ON_HULL_CHECK,     False)
      self.ToolbarL.ToggleTool(self.ToolbarL.ON_CENTROID_CHECK, True)
      self.Display_Objects( True )
      self.Display_Trajectories()
    else:
      self.CurrentView = VIEW_FRAMES
      self.PrevButton.Enable()
      self.NextButton.Enable()
      self.FrameSlider.Enable()
      self.XAxisScaleButton.Enable()
      self.YAxisScaleButton.Enable()
      self.ZAxisScaleButton.Enable()
      self.ScaleState[X] = self.PrevScaleState[X]
      self.ScaleState[Y] = self.PrevScaleState[Y]
      self.ScaleState[Z] = self.PrevScaleState[Z]
      self.ToolbarL.ToggleTool(self.ToolbarL.ON_SCATTER_CHECK,  True)
      self.ToolbarL.ToggleTool(self.ToolbarL.ON_HULL_CHECK,     False)
      self.ToolbarL.ToggleTool(self.ToolbarL.ON_CENTROID_CHECK, False)
      self.Display_Objects( True )
    self.Set_Scales()
    self.CanvasL.draw()

    # def SetupView(self):
    #   if (self.CurrentView == VIEW_FRAMES):
    #     self.ViewButton.SetLabel("Switch to "+VIEW_TRAJECTORY+" view")
    #     self.PrevButton.Enable()
    #     self.NextButton.Enable()
    #     self.FrameSlider.Enable()
    #     self.ResolutionSlider.Enable()
    #     self.PredictExperiments.Enable()
    #     self.RegressionTypeCombo.Enable()
    #     self.ToolbarL.ToggleTool(self.ToolbarL.ON_SCATTER_CHECK,  True)
    #     self.ToolbarL.ToggleTool(self.ToolbarL.ON_HULL_CHECK,     False)
    #     self.ToolbarL.ToggleTool(self.ToolbarL.ON_CENTROID_CHECK, False)
    #   elif (self.CurrentView == VIEW_TRAJECTORY):
    #     self.ViewButton.SetLabel("Switch to "+VIEW_FRAMES+" view")
    #     self.PrevButton.Disable()
    #     self.NextButton.Disable()
    #     self.FrameSlider.Disable()
    #     self.ResolutionSlider.Disable()
    #     self.PredictExperiments.Disable()
    #     self.RegressionTypeCombo.Disable()
    #     self.ToolbarL.ToggleTool(self.ToolbarL.ON_SCATTER_CHECK,  False)
    #     self.ToolbarL.ToggleTool(self.ToolbarL.ON_HULL_CHECK,     False)
    #     self.ToolbarL.ToggleTool(self.ToolbarL.ON_CENTROID_CHECK, True)
    #   self.ViewButton.Enable()
    #   self.PlayButton.Enable()
    #   self.ClustersScroll.Enable()
    #   self.MetricsScroll.Enable()


#
# main()
#

def Usage():
  print sys.argv[0], "<tracking_output.xtrack>"

#
# Parse arguments
#
argc = len(sys.argv)

Config = ConfigParser.ConfigParser()
Config.read(sys.argv[1])

def ReadConfig(section):
  dict = {}
  options = Config.options(section)
  for option in options:
    dict[option] = Config.get(section, option)
  return dict
NumberOfFrames = int(ReadConfig('Info')['frames'])

app = wx.PySimpleApp(False)
app.main = MainFrame(None, "Tracking")
app.main.Show()
app.MainLoop()
