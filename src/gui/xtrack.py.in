#!/usr/bin/env python

import wxversion
wxversion.ensureMinimal('2.8')
import wx
import wx.aui
import wx.lib.buttons as buttons
import matplotlib
matplotlib.use('WXAgg')
import matplotlib.mlab as mlab
from matplotlib.figure import Figure
from matplotlib.backends.backend_wxagg import \
    FigureCanvasWxAgg as FigCanvas, \
    NavigationToolbar2WxAgg as NavigationToolbar
from matplotlib.patches import Polygon
from matplotlib.patches import FancyArrowPatch
import matplotlib.animation as animation
from matplotlib.lines import Line2D
from mpl_toolkits.mplot3d.art3d import Line3D
import matplotlib.pyplot as plt
from collections import defaultdict
from scipy.interpolate import interp1d
from scipy.stats import nanmean
from scipy.spatial import qhull
try:
  from scipy.sparse import csgraph, csr_matrix
  from scipy.sparse.csgraph import depth_first_order
  CanDoHulls = True
except:
  CanDoHulls = False
from scipy.optimize import curve_fit
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from mpl_toolkits.mplot3d import proj3d
import math
import sys
import numpy as np
from numpy import nanmin, nanmax
#import convexhull as ch
import time
import os.path
import subprocess
import ConfigParser
import traceback

INSTALLATION_PATH=os.getenv('TRACKING_HOME')

#
# Defines
#
matplotlib.rcParams.update({'font.size': 10})

CLUSTER_ID              = 'clusterid'
FIRST_CLUSTER_ID_CSV    =  6
INDEX_FIRST_METRIC_CSV  =  7
INDEX_LAST_METRIC_CSV   = -1
SIZE_EMPTY_HISTOGRAM    = 29 # This is the size of the header when the histogram is empty
VIEW_FRAMES     = 0
VIEW_TRACKING = 1 
X = 0
Y = 1
Z = 2
HIDE_ALL       = 0
HIDE_SCATTERS  = 1
HIDE_CENTROIDS = 2
HIDE_HULLS     = 3
HIDE_ARROWS    = 4
HIDE_PATHS     = 5
SHOW_OBJECTS_NORMAL = 0
SHOW_OBJECTS_SCALED = 1
FITTING_POLY_1  = 0
FITTING_POLY_2  = 1
FITTING_POLY_3  = 2
FITTING_LOG     = 3
FITTING_LIN_LOG = 4


#
# Global variables
#
Data             = { }
Callers          = { }
Metrics          = { }
NumberOfFrames   = 0
NumberOfClusters = 0
FirstCluster     = FIRST_CLUSTER_ID_CSV;
LastCluster      = FirstCluster
TasksPerFrame    = [ ]
Traces           = [ ]

#
# PRV color palette
#
ColorPalette      = [ ( 117, 195, 255 ), (   0,   0, 255 ), ( 255, 255, 255 ), ( 255,   0,   0 ), ( 255,   0, 174 ), ( 179,   0,   0 ), ( 0,   255,   0 ), ( 255, 255,   0 ), ( 235,   0,   0 ), (   0, 162,   0 ), ( 255,   0, 255 ), ( 100, 100,  177 ), ( 172, 174,  41 ), ( 255, 144,  26 ), (   2, 255, 177 ), ( 192, 224,   0 ), (  66,  66,  66 ), ( 189, 168, 100 ), (  95, 200,   0 ), ( 203,  60,  69 ), (   0, 109, 255 ), ( 200,  61,  68 ), ( 200,  66,   0 ), (   0,  41,   0 ), ( 139, 121, 177 ), ( 116, 116, 116 ), ( 200,  50,  89 ), ( 255, 171,  98 ), (   0,  68, 189 ), (  52,  43,   0 ), ( 255,  46,   0 ), ( 100, 216,  32 ), (   0,   0, 112 ), ( 105, 105,   0 ), ( 132,  75, 255 ), ( 184, 232,   0 ), (   0, 109, 112 ), ( 189, 168, 100 ), ( 132,  75,  75 ), ( 255,  75,  75 ), ( 255,  20,   0 ), (  52,   0,   0 ), (   0,  66,   0 ), ( 184, 132,   0 ), ( 100,  16,  32 ), ( 146, 255, 255 ), (   0,  23,  37 ), ( 146,   0, 255 ), (   0, 138, 119 ) ]
Color_Selected    = (0.20, 0.75, 0.80)
Color_NonSelected = (1, 1, 1)

def PRVColor(cluster_id):
    idx = cluster_id
    if (idx > len(ColorPalette)): idx = len(ColorPalette) - 1
    r = float(float(ColorPalette[idx][0]) / 255)
    g = float(float(ColorPalette[idx][1]) / 255)
    b = float(float(ColorPalette[idx][2]) / 255)
    rgb = (r, g, b)
    return rgb

def MetricColor(metric):
    return PRVColor( (Metrics[1].index(metric) + 20) % len(ColorPalette))

Markers = ['o', '+', '*', 's', 'd', '8', 'p', 'D', 'h', 'H', '4', '5', '6', '_', '3', '0', '1', '2', '1', '3', '4', '2', 'v', '<', '>', '^', '|', 'x', ',', '.'] 

def ChooseMarker(cluster_id):
  return Markers[(cluster_id-FirstCluster) % len(Markers)]

def ClusterOffset(cluster_id):
    return cluster_id - FirstCluster + 1

def isClusteringDimension(metric_name):
  if (metric_name[0:2] == 'd_'):
    return 1
  return 0

def isExtrapolatedMetric(metric_name):
  if (metric_name[0:2] == 'x_'):
    return 1
  return 0

def fitting_log(x, a, b):
  return a*np.log(x)+b

def fitting_lin_log(x, a, b):
  return a*x*np.log(x)+b

def fitting_poly_1(x, a, b):
  return (a*x) + b

def fitting_poly_2(x, a, b, c):
  return a*np.power(x,2) + b*x + c

def fitting_poly_3(x, a, b, c, d):
  return a*np.power(x,3) + b*np.power(x,2) + c*x + d


class Arrow3D(FancyArrowPatch):
    def __init__(self, xs, ys, zs, *args, **kwargs):
        FancyArrowPatch.__init__(self, (0,0), (0,0), *args, **kwargs)
        self._verts3d = xs, ys, zs

    def draw(self, renderer):
        xs3d, ys3d, zs3d = self._verts3d
        xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, renderer.M)
        self.set_positions((xs[0],ys[0]),(xs[1],ys[1]))
        FancyArrowPatch.draw(self, renderer)

class ToolbarL(NavigationToolbar):
  #
  # Extend the default wx toolbar with your own event handlers
  #  
  ON_SCATTER_CHECK = wx.NewId()
  ON_CENTROID_CHECK = wx.NewId()
  ON_HULL_CHECK = wx.NewId()
  ON_GRID_CHECK = wx.NewId()

  def __init__(self, canvas):
    NavigationToolbar.__init__(self, canvas)

    self.AddSeparator()

    self.AddCheckTool(
      self.ON_GRID_CHECK,
      wx.Bitmap(INSTALLATION_PATH+'/etc/icons/grid.png'),
      wx.Bitmap(INSTALLATION_PATH+'/etc/icons/grid.png'),
      'Shows the grid',
      'Shows the grid')

    self.AddSeparator()

    self.AddCheckTool(
      self.ON_SCATTER_CHECK,
      wx.Bitmap(INSTALLATION_PATH+'/etc/icons/scatter.png'),
      wx.Bitmap(INSTALLATION_PATH+'/etc/icons/scatter.png'),
      'Draw the points of the cluster',
      'Draw the points of the cluster')

    self.AddCheckTool(
      self.ON_CENTROID_CHECK,
      wx.Bitmap(INSTALLATION_PATH+'/etc/icons/centroid.png'),
      wx.Bitmap(INSTALLATION_PATH+'/etc/icons/centroid.png'),
      'Draw the centroid of the cluster',
      'Draw the centroid of the cluster')

    self.CheckHull = self.AddCheckTool(
      self.ON_HULL_CHECK,
      wx.Bitmap(INSTALLATION_PATH+'/etc/icons/hull.png'),
      wx.Bitmap(INSTALLATION_PATH+'/etc/icons/hull.png'),
      'Draw the perimeter of the cluster',
      'Draw the perimeter of the cluster')

    self.ToggleTool(self.ON_SCATTER_CHECK, True)

    wx.EVT_TOOL(self, self.ON_GRID_CHECK, self.on_Grid_Check)
    wx.EVT_TOOL(self, self.ON_SCATTER_CHECK, self.on_Scatter_Check)
    wx.EVT_TOOL(self, self.ON_HULL_CHECK, self.on_Hull_Check)
    wx.EVT_TOOL(self, self.ON_CENTROID_CHECK, self.on_Centroid_Check)

    if not CanDoHulls:
      self.EnableTool(self.ON_HULL_CHECK, False)
   
  def on_Grid_Check(self, event):
    app.main.AxesL.grid( b=self.GetToolState(self.ON_GRID_CHECK) )
    app.main.CanvasL.draw()

  def on_Scatter_Check(self, event):
    if (self.GetToolState(self.ON_SCATTER_CHECK) == True):
      app.main.Display_Scatters()
    else:
      app.main.Hide_Objects(HIDE_SCATTERS)
    app.main.CanvasL.draw()

  def on_Centroid_Check(self, event):
    if (self.GetToolState(self.ON_CENTROID_CHECK) == True):
      app.main.Display_Centroids()
    else:
      app.main.Hide_Objects(HIDE_CENTROIDS)
    app.main.CanvasL.draw()

  def on_Hull_Check(self, event):
    if (self.GetToolState(self.ON_HULL_CHECK) == True):
      app.main.Display_Hulls()
    else:
      app.main.Hide_Objects(HIDE_HULLS)
    app.main.CanvasL.draw()


class ToolbarR(NavigationToolbar):
  #
  # Extend the default wx toolbar with your own event handlers
  #  
  ON_BOXPLOT_CHECK = wx.NewId()
  ON_LEGEND_CHECK = wx.NewId()
  ON_GRID_CHECK = wx.NewId()

  def __init__(self, canvas):
    NavigationToolbar.__init__(self, canvas)

    self.AddSeparator()

    self.AddCheckTool(
      self.ON_GRID_CHECK,
      wx.Bitmap(INSTALLATION_PATH+'/etc/icons/grid.png'),
      wx.Bitmap(INSTALLATION_PATH+'/etc/icons/grid.png'),
      'Shows the grid',
      'Shows the grid')


    self.AddSeparator()

    self.AddCheckTool(
      self.ON_BOXPLOT_CHECK,
      wx.Bitmap(INSTALLATION_PATH+'/etc/icons/boxplot.png'),
      wx.Bitmap(INSTALLATION_PATH+'/etc/icons/boxplot.png'),
      'Switch between boxplots and trend lines',
      'Switch between boxplots and trend lines')

    self.AddCheckTool(
      self.ON_LEGEND_CHECK,
      wx.Bitmap(INSTALLATION_PATH+'/etc/icons/legend.png'),
      wx.Bitmap(INSTALLATION_PATH+'/etc/icons/legend.png'),
      'Show plots legends',
      'Show plots legends')

    wx.EVT_TOOL(self, self.ON_GRID_CHECK, self.on_Grid_Check)
    wx.EVT_TOOL(self, self.ON_BOXPLOT_CHECK, self.on_Boxplot_Check)
    wx.EVT_TOOL(self, self.ON_LEGEND_CHECK, self.on_Legend_Check)

  def on_Grid_Check(self, event):
    app.main.AxesR1.grid( b=self.GetToolState(self.ON_GRID_CHECK) )
    app.main.AxesR2.grid( b=self.GetToolState(self.ON_GRID_CHECK) )
    app.main.CanvasR.draw()

  def on_Boxplot_Check(self, event):
      app.main.PlotR()

  def on_Legend_Check(self, event):
      app.main.PlotR()


class MainFrame(wx.Frame, animation.TimedAnimation):
  #
  # The main frame of the application
  #

  def __init__(self, parent, title):
    #
    # A "-1" in the size parameter instructs wxWidgets to use the default size.
    #
    wx.Frame.__init__(self, parent, title=title)

    self.Objects        = defaultdict()
    self.ObjectsScaled  = defaultdict()
    self.ShowingObjects = defaultdict()
    self.NowShowing     = SHOW_OBJECTS_NORMAL

    self.DisplayingClusters = defaultdict()
    self.DisplayingMetrics  = defaultdict()
 
    # self.Bins = 25

    self.bmp_display         = wx.Bitmap(INSTALLATION_PATH+"/etc/icons/display.png")
    self.bmp_nodisplay       = wx.Bitmap(INSTALLATION_PATH+"/etc/icons/nodisplay.png")
    self.bmp_play            = wx.Bitmap(INSTALLATION_PATH+"/etc/icons/play.png")
    self.bmp_prev            = wx.Bitmap(INSTALLATION_PATH+"/etc/icons/prev.png")
    self.bmp_next            = wx.Bitmap(INSTALLATION_PATH+"/etc/icons/next.png")
    self.bmp_log_on          = wx.Bitmap(INSTALLATION_PATH+"/etc/icons/log_on.png")
    self.bmp_log_off         = wx.Bitmap(INSTALLATION_PATH+"/etc/icons/log_off.png")
    self.bmp_scale_on        = wx.Bitmap(INSTALLATION_PATH+"/etc/icons/scale_on.png")
    self.bmp_scale_off       = wx.Bitmap(INSTALLATION_PATH+"/etc/icons/scale_off.png")
    self.bmp_trajectory_view = wx.Bitmap(INSTALLATION_PATH+"/etc/icons/tracking_view.png")
    self.bmp_frames_view     = wx.Bitmap(INSTALLATION_PATH+"/etc/icons/frames_view.png")
    self.bmp_swap            = wx.Bitmap(INSTALLATION_PATH+"/etc/icons/swap.png")
    self.bmp_timeline        = wx.Bitmap(INSTALLATION_PATH+"/etc/icons/timeline.png")

    self.LoadData()

    self.Create_Main_Panel()

    self.PlotL()
    self.PlotR()

    # self.SetupView()

    # self.ComputePlots()

    # self.PlotAll()
    # self.FigR.subplots_adjust(left=0.06, bottom=0.05, right=0.99, top=0.95, wspace=0.11, hspace=0.19)

  def Create_Main_Panel(self):

    #
    # Change the default font size
    #
    self.Panel = wx.Panel(self)
        
    #
    # Create the mpl Figures and Canvas objects (5x4 inches, 100 dots-per-inch)
    #
    self.DPI     = 100
    self.FigL    = Figure((5.0, 4.0), dpi=self.DPI)
    self.CanvasL = FigCanvas(self.Panel, -1, self.FigL)
    self.AxesL   = self.FigL.add_subplot(111)
    self.FigL.set_facecolor("#FFFFFF")

    self.FigR     = Figure((5.0, 4.0), dpi=self.DPI)
    self.CanvasR  = FigCanvas(self.Panel, -1, self.FigR)
    self.FigR.set_facecolor("#FFFFFF")
    # self.ColorBar = ()

    #
    # Create the navigation toolbars, tied to the canvas
    #
    self.ToolbarL = ToolbarL(self.CanvasL)
    self.ToolbarR = ToolbarR(self.CanvasR)

    #
    # Axes frame
    #
    self.AxesBox       = wx.StaticBox(self.Panel, -1, "Axes") 
    self.AxesBoxSizer  = wx.StaticBoxSizer(self.AxesBox, wx.HORIZONTAL)    
    self.AxesBoxSizer1 = wx.BoxSizer(wx.VERTICAL)
    self.AxesBoxSizer2 = wx.BoxSizer(wx.VERTICAL)
    self.AxesBoxSizer3 = wx.BoxSizer(wx.VERTICAL)
    self.AxesBoxSizer4 = wx.BoxSizer(wx.VERTICAL)
    self.AxesBoxSizer5 = wx.BoxSizer(wx.VERTICAL)
    self.AxesBoxSizer.Add( self.AxesBoxSizer1 )
    self.AxesBoxSizer.Add( self.AxesBoxSizer2 )
    self.AxesBoxSizer.Add( self.AxesBoxSizer3 )
    self.AxesBoxSizer.Add( self.AxesBoxSizer4 )
    self.AxesBoxSizer.Add( self.AxesBoxSizer5 )

    # Swap button
    self.AxesSwapButton   = wx.BitmapButton(self.Panel, -1, size=(30,60), bitmap=self.bmp_swap)
    self.Bind(wx.EVT_BUTTON, self.on_Swap_Button, self.AxesSwapButton)

    # 3D button
    self.Activate3DButton = wx.ToggleButton(self.Panel, -1, "3D", size=(30,30), style=wx.EXPAND)
    self.Bind(wx.EVT_TOGGLEBUTTON, self.on_3D_Button, self.Activate3DButton)

    # X, Y, Z axes combos
    mxs = [ m.upper()[2:] for m in Metrics[self.FocusOnFrame]]
    self.XAxisLabel = wx.StaticText(self.Panel, -1, "  X: ")
    self.XAxisCombo = wx.ComboBox(self.Panel, -1, choices=mxs, size=(-1,30), style=wx.CB_READONLY)
    self.XAxisCombo.SetSelection(1)
    self.YAxisLabel = wx.StaticText(self.Panel, -1, "  Y: ")
    self.YAxisCombo = wx.ComboBox(self.Panel, -1, choices=mxs, size=(-1,30), style=wx.CB_READONLY)
    self.YAxisCombo.SetSelection(0)
    self.ZAxisLabel = wx.StaticText(self.Panel, -1, "  Z: ")
    self.ZAxisCombo = wx.ComboBox(self.Panel, -1, choices=mxs, size=(-1,30), style=wx.CB_READONLY)
    if (len(Metrics[self.FocusOnFrame]) > 2):
      self.ZAxisCombo.SetSelection(2)
    self.ZAxisCombo.Disable()
    self.Bind(wx.EVT_COMBOBOX, self.on_XAxisCombo_Change, self.XAxisCombo)
    self.Bind(wx.EVT_COMBOBOX, self.on_YAxisCombo_Change, self.YAxisCombo)
    self.Bind(wx.EVT_COMBOBOX, self.on_ZAxisCombo_Change, self.ZAxisCombo)

    # Log scale buttons
    self.XAxisLogButton = wx.BitmapButton(self.Panel, -1, size=(60,30), bitmap=self.bmp_log_off)
    self.Bind(wx.EVT_BUTTON, self.on_XLog_Button, self.XAxisLogButton)
    self.YAxisLogButton = wx.BitmapButton(self.Panel, -1, size=(60,30), bitmap=self.bmp_log_off)
    self.Bind(wx.EVT_BUTTON, self.on_YLog_Button, self.YAxisLogButton)
    self.ZAxisLogButton = wx.BitmapButton(self.Panel, -1, size=(60,30), bitmap=self.bmp_log_off)
    self.Bind(wx.EVT_BUTTON, self.on_ZLog_Button, self.ZAxisLogButton)
    self.ZAxisLogButton.Disable()
    self.LogState = [0, 0, 0]

    # Scale to number of tasks buttons
    self.XAxisScaleButton = wx.BitmapButton(self.Panel, -1, size=(60,30), bitmap=self.bmp_scale_off)
    self.Bind(wx.EVT_BUTTON, self.on_XScale_Button, self.XAxisScaleButton)
    self.YAxisScaleButton = wx.BitmapButton(self.Panel, -1, size=(60,30), bitmap=self.bmp_scale_off)
    self.Bind(wx.EVT_BUTTON, self.on_YScale_Button, self.YAxisScaleButton)
    self.ZAxisScaleButton = wx.BitmapButton(self.Panel, -1, size=(60,30), bitmap=self.bmp_scale_off)
    self.Bind(wx.EVT_BUTTON, self.on_ZScale_Button, self.ZAxisScaleButton)
    self.ZAxisScaleButton.Disable()
    self.ScaleState     = [0, 0, 0]
    self.PrevScaleState = [0, 0, 0]

    # Arrange the widgets
    self.AxesBoxSizer1.Add( self.AxesSwapButton, 0, wx.ALIGN_LEFT | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    self.AxesBoxSizer1.Add( self.Activate3DButton, 0, wx.ALIGN_LEFT | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    self.AxesBoxSizer2.AddSpacer(6)
    self.AxesBoxSizer2.Add( self.XAxisLabel, 0, wx.ALIGN_RIGHT, wx.ALIGN_BOTTOM)
    self.AxesBoxSizer2.AddSpacer(11)
    self.AxesBoxSizer2.Add( self.YAxisLabel, 0, wx.ALIGN_RIGHT, wx.ALIGN_BOTTOM)
    self.AxesBoxSizer2.AddSpacer(11)
    self.AxesBoxSizer2.Add( self.ZAxisLabel, 0, wx.ALIGN_RIGHT, wx.ALIGN_BOTTOM)
    self.AxesBoxSizer3.Add( self.XAxisCombo, 0, wx.ALIGN_LEFT | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    self.AxesBoxSizer3.Add( self.YAxisCombo, 0, wx.ALIGN_LEFT | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    self.AxesBoxSizer3.Add( self.ZAxisCombo, 0, wx.ALIGN_LEFT | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    self.AxesBoxSizer4.Add( self.XAxisLogButton, 0, wx.ALIGN_LEFT | wx.ALIGN_CENTER_VERTICAL)
    self.AxesBoxSizer4.Add( self.YAxisLogButton, 0, wx.ALIGN_LEFT | wx.ALIGN_CENTER_VERTICAL)
    self.AxesBoxSizer4.Add( self.ZAxisLogButton, 0, wx.ALIGN_LEFT | wx.ALIGN_CENTER_VERTICAL)
    self.AxesBoxSizer5.Add( self.XAxisScaleButton, 0, wx.ALIGN_LEFT | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    self.AxesBoxSizer5.Add( self.YAxisScaleButton, 0, wx.ALIGN_LEFT | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    self.AxesBoxSizer5.Add( self.ZAxisScaleButton, 0, wx.ALIGN_LEFT | wx.ALL | wx.ALIGN_CENTER_VERTICAL)

    #
    # Frame selector 
    #
    self.FrameBox      = wx.StaticBox(self.Panel, -1, "Viewing frame", style=wx.EXPAND)
    self.FrameBoxSizer = wx.StaticBoxSizer(self.FrameBox, wx.HORIZONTAL)
    self.PrevButton = wx.BitmapButton(self.Panel, -1, size=(30,43), bitmap=self.bmp_prev)
    self.Bind(wx.EVT_BUTTON, self.on_Prev_Button, self.PrevButton)
    self.NextButton = wx.BitmapButton(self.Panel, -1, size=(30,43), bitmap=self.bmp_next)
    self.Bind(wx.EVT_BUTTON, self.on_Next_Button, self.NextButton)
    self.PlayButton = wx.BitmapButton(self.Panel, -1, size=(30,43), bitmap=self.bmp_play)
    self.Bind(wx.EVT_BUTTON, self.on_Play_Button, self.PlayButton)
    self.FrameSlider = wx.Slider(self.Panel, -1,
      value=self.FocusOnFrame, 
      minValue=1,
      maxValue=NumberOfFrames,
      style=wx.SL_HORIZONTAL | wx.SL_AUTOTICKS | wx.SL_LABELS)
    self.FrameSlider.SetTickFreq(1, 1)
    self.Bind(wx.EVT_COMMAND_SCROLL_CHANGED, self.on_Frame_Change, self.FrameSlider)
    self.TrackingButton = wx.BitmapButton(self.Panel, -1, size=(74,43), bitmap=self.bmp_trajectory_view)
    self.Bind(wx.EVT_BUTTON, self.on_Tracking_Button, self.TrackingButton)
    self.TimelineButton = wx.BitmapButton(self.Panel, -1, size=(74,43), bitmap=self.bmp_timeline)
    self.Bind(wx.EVT_BUTTON, self.on_Timeline_Button, self.TimelineButton)
    self.FrameBoxSizer.Add( self.PrevButton,     0, wx.ALIGN_LEFT  | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    self.FrameBoxSizer.Add( self.FrameSlider,    1, wx.EXPAND      | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    self.FrameBoxSizer.Add( self.NextButton,     0, wx.ALIGN_RIGHT | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    self.FrameBoxSizer.Add( self.PlayButton,     0, wx.ALIGN_LEFT  | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    self.FrameBoxSizer.Add( self.TimelineButton, 0, wx.ALIGN_RIGHT | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    self.FrameBoxSizer.Add( self.TrackingButton, 0, wx.ALIGN_RIGHT | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    
    #
    # Create timers
    #
    self.PlayTimer = wx.Timer(self)
    self.Bind(wx.EVT_TIMER, self.on_Playing_Timer, self.PlayTimer)
   
    #
    # Clusters scroll
    #
    self.ClustersScroll     = wx.ScrolledWindow(self.Panel, -1, style=wx.VSCROLL | wx.HSCROLL, size=(100,-1))
    self.ClustersScrollList = []
    for cluster_id in range(FirstCluster, LastCluster+1):
      ClustersDisplayToggle = wx.BitmapButton(self.ClustersScroll, -1, bitmap=self.bmp_display, size=(26, 26), name=str(cluster_id))   
      ClustersFocusToggle   = wx.ToggleButton(self.ClustersScroll, -1, "Region "+str(cluster_id-FirstCluster+1), size=(-1,26), name=str(cluster_id), style=wx.BU_LEFT)
      default_font = ClustersFocusToggle.GetFont()
      default_font.SetPointSize(8)
      ClustersFocusToggle.SetFont(default_font) 

      self.Bind(wx.EVT_BUTTON, self.on_Clusters_Display, ClustersDisplayToggle)
      self.Bind(wx.EVT_TOGGLEBUTTON, self.on_Clusters_Focus, ClustersFocusToggle)
      c = PRVColor(cluster_id)
      ClustersDisplayToggle.SetBackgroundColour(wx.Colour(c[0]*255, c[1]*255, c[2]*255))
      self.ClustersScrollList.append((ClustersDisplayToggle, ClustersFocusToggle))
      self.DisplayingClusters[cluster_id] = True

    ClustersScrollSizer   = wx.BoxSizer(wx.HORIZONTAL)
    ClustersScrollSizerV1 = wx.BoxSizer(wx.VERTICAL)
    ClustersScrollSizerV2 = wx.BoxSizer(wx.VERTICAL)
    for controls in self.ClustersScrollList:
      ClustersScrollSizerV1.Add(controls[0], 0, wx.ALIGN_LEFT)
      ClustersScrollSizerV2.Add(controls[1], 0, wx.ALIGN_LEFT | wx.EXPAND)
    ClustersScrollSizer.Add(ClustersScrollSizerV1)
    ClustersScrollSizer.Add(ClustersScrollSizerV2)

    self.ClustersScroll.SetSizer(ClustersScrollSizer)
#    self.ClustersScroll.Fit()
#    self.ClustersScroll.FitInside()
    self.ClustersScroll.SetScrollbars(20, 20, 50, 50)


    self.ClustersLegendBox = wx.StaticBox(self.Panel, -1, "Display regions", style=wx.EXPAND, size=(100,-1))
    self.ClustersLegendBoxSizer = wx.StaticBoxSizer(self.ClustersLegendBox, wx.VERTICAL)
    self.ClustersLegendBoxSizer.Add( self.ClustersScroll, 1, wx.EXPAND )
    self.set_Cluster_Focus(FirstCluster)

    #
    # Metrics scroll
    #
    self.MetricsScroll     = wx.ScrolledWindow(self.Panel, -1, style=wx.VSCROLL | wx.HSCROLL, size=(100,-1))
    self.MetricsScrollList = []
    for metric in Metrics[self.FocusOnFrame]:
      if (isClusteringDimension(metric)):
        display_by_default = True
        bitmap = self.bmp_display
      else:
        display_by_default = False
        bitmap = self.bmp_nodisplay

      MetricsDisplayToggle = wx.BitmapButton(self.MetricsScroll, -1, bitmap=bitmap, size=(26, 26), name=metric)
      MetricsFocusToggle   = wx.ToggleButton(self.MetricsScroll, -1, metric.upper()[2:], size=(-1,26), name=metric, style=wx.BU_LEFT)
      default_font = MetricsFocusToggle.GetFont()
      default_font.SetPointSize(8)
      MetricsFocusToggle.SetFont(default_font) 

      self.Bind(wx.EVT_BUTTON, self.on_Metrics_Display, MetricsDisplayToggle)
      self.Bind(wx.EVT_TOGGLEBUTTON, self.on_Metrics_Focus, MetricsFocusToggle)
      c = MetricColor(metric)
      MetricsDisplayToggle.SetBackgroundColour(wx.Colour(c[0]*255, c[1]*255, c[2]*255))
      self.MetricsScrollList.append((MetricsDisplayToggle, MetricsFocusToggle))
      self.DisplayingMetrics[metric] = display_by_default

    MetricsScrollSizer   = wx.BoxSizer(wx.HORIZONTAL)
    MetricsScrollSizerV1 = wx.BoxSizer(wx.VERTICAL)
    MetricsScrollSizerV2 = wx.BoxSizer(wx.VERTICAL)
    for controls in self.MetricsScrollList:
      MetricsScrollSizerV1.Add( controls[0], 0, wx.ALIGN_LEFT) 
      MetricsScrollSizerV2.Add( controls[1], 0, wx.ALIGN_LEFT | wx.EXPAND) 
    MetricsScrollSizer.Add( MetricsScrollSizerV1)
    MetricsScrollSizer.Add( MetricsScrollSizerV2)

    self.MetricsScroll.SetSizer(MetricsScrollSizer)
#    self.MetricsScroll.Fit()
#    self.MetricsScroll.FitInside()
    self.MetricsScroll.SetScrollbars(20, 20, 50, 50)

    self.MetricsLegendBox = wx.StaticBox(self.Panel, -1, "Display metrics", style=wx.EXPAND, size=(100,-1))
    self.MetricsLegendBoxSizer = wx.StaticBoxSizer(self.MetricsLegendBox, wx.VERTICAL)

    self.MetricsLegendBoxSizer.Add( self.MetricsScroll, 1, wx.EXPAND )
    self.set_Metric_Focus(Metrics[self.FocusOnFrame][0])

    # self.HeatMapConfigBox = wx.StaticBox(self.Panel, -1, "Heat map resolution", style=wx.EXPAND)
    # self.HeatMapConfigBoxSizer = wx.StaticBoxSizer(self.HeatMapConfigBox, wx.HORIZONTAL)
    # self.ResolutionSlider = wx.Slider(self.Panel, -1,
    #   value=25,
    #   minValue=5,
    #   maxValue=50,
    #   style=wx.SL_HORIZONTAL | wx.SL_AUTOTICKS | wx.SL_LABELS)
    # self.ResolutionSlider.SetTickFreq(1, 1)
    # self.Bind(wx.EVT_COMMAND_SCROLL_CHANGED, self.on_Resolution_Change, self.ResolutionSlider)
    # self.HeatMapConfigBoxSizer.Add( self.ResolutionSlider, 1, wx.EXPAND )


    #
    # Fitting
    #
    self.FittingBox = wx.StaticBox(self.Panel, -1, "Fitting")
    self.PredictExperimentsLabel = wx.StaticText(self.Panel, -1, "Samples: ")
    self.PredictExperiments = wx.TextCtrl(self.Panel, -1, size=(100, 26), style=wx.TE_PROCESS_ENTER)
    self.PredictExperiments.SetValue("0")
    self.Bind(wx.EVT_TEXT_ENTER, self.on_Prediction_Change, self.PredictExperiments)

    RegressionModelList = ['Linear', 'Quadratic', 'Cubic', 'Log', 'Linear log' ]
    self.RegressionModelLabel = wx.StaticText(self.Panel, -1, "Model: ")
    self.RegressionModelCombo = wx.ComboBox( self.Panel, -1, value=RegressionModelList[0], size=(100, 26), choices=RegressionModelList, style=wx.CB_DROPDOWN)
    self.RegressionModelCombo.SetSelection(0)
    self.Bind(wx.EVT_COMBOBOX, self.on_RegressionModel_Change, self.RegressionModelCombo)

    self.FittingLabel = wx.StaticText(self.Panel, -1, "")
    self.FittingLabel.Disable()

    self.FittingBoxSizerH = wx.BoxSizer( wx.HORIZONTAL )
    self.FittingBoxSizerH.Add( self.PredictExperimentsLabel, 1, wx.ALIGN_CENTER_VERTICAL)
    self.FittingBoxSizerH.Add( self.PredictExperiments,      3, wx.EXPAND | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    self.FittingBoxSizerH.AddSpacer(10)
    self.FittingBoxSizerH.Add( self.RegressionModelLabel,    1, wx.ALIGN_CENTER_VERTICAL)
    self.FittingBoxSizerH.Add( self.RegressionModelCombo,    3, wx.EXPAND | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    self.FittingBoxSizer = wx.StaticBoxSizer(self.FittingBox, wx.VERTICAL ) 
    self.FittingBoxSizer.Add( self.FittingBoxSizerH )
    self.FittingBoxSizer.Add( self.FittingLabel, 1, wx.EXPAND )

    #
    # General layout 
    #
    self.PlotLControls1 = wx.BoxSizer(wx.HORIZONTAL)
    self.PlotLControls1.Add(self.AxesBoxSizer, 1, wx.EXPAND | wx.ALL | wx.ALIGN_CENTER_VERTICAL)

    # self.PlotLControls2 = wx.BoxSizer(wx.HORIZONTAL)
    # self.PlotLControls2.Add(self.ViewModeBoxSizer, 1, wx.EXPAND | wx.ALL | wx.ALIGN_CENTER_VERTICAL)

    self.PlotLControls3 = wx.BoxSizer(wx.HORIZONTAL)
    self.PlotLControls3.Add( self.FrameBoxSizer, 1, wx.EXPAND )

    # self.PlotLControls4 = wx.BoxSizer(wx.HORIZONTAL)
    # self.PlotLControls4.Add( self.HeatMapConfigBoxSizer, 1, wx.EXPAND | wx.ALL | wx.ALIGN_CENTER_VERTICAL)
    # self.PlotLControls4.Add( self.PredictionBoxSizer, 1, wx.EXPAND | wx.ALL | wx.ALIGN_CENTER_VERTICAL)

    self.PlotLBox = wx.BoxSizer(wx.VERTICAL)
    self.PlotLBox.Add(self.ToolbarL, 0)
    self.PlotLBox.Add(self.CanvasL, 1, wx.LEFT | wx.TOP | wx.GROW)
    self.PlotLBox.Add(self.PlotLControls1, 0, flag = wx.TOP | wx.EXPAND)
    # self.PlotLBox.Add(self.PlotLControls2, 0, flag = wx.TOP | wx.EXPAND)
    self.PlotLBox.Add(self.PlotLControls3, 0, flag = wx.TOP | wx.EXPAND)
    # self.PlotLBox.Add(self.PlotLControls4, 0, flag = wx.TOP | wx.EXPAND)

    self.LegendBox = wx.BoxSizer(wx.VERTICAL)
    self.LegendBox.AddSpacer(30)
    self.LegendBox.Add(self.ClustersLegendBoxSizer, 1, wx.EXPAND)
    self.LegendBox.Add(self.MetricsLegendBoxSizer, 1, wx.EXPAND)

    self.PlotRControls1 = wx.BoxSizer(wx.HORIZONTAL)
    self.PlotRControls1.Add( self.FittingBoxSizer, 1, wx.EXPAND | wx.ALL | wx.ALIGN_CENTER_VERTICAL )

    self.PlotRBox = wx.BoxSizer(wx.VERTICAL)
    self.PlotRBox.Add(self.ToolbarR, 0)
    self.PlotRBox.Add(self.CanvasR, 1, wx.LEFT | wx.TOP | wx.EXPAND)
    self.PlotRBox.Add(self.PlotRControls1)


    self.WindowBox = wx.BoxSizer(wx.HORIZONTAL)
    self.WindowBox.Add(self.PlotLBox, 3, wx.EXPAND)
    self.WindowBox.Add(self.LegendBox, 1, wx.EXPAND)
    self.WindowBox.Add(self.PlotRBox, 3, wx.EXPAND)

    self.Panel.SetSizer(self.WindowBox)
    self.WindowBox.Fit(self)

    self.SetMinSize(self.GetSize())
    self.CurrentView = VIEW_FRAMES

  def LoadData(self):
    global LastCluster
    global NumberOfClusters
    global TasksPerFrame

    for frame in range(1, NumberOfFrames+1):
      config = ReadConfig('Frame '+str(frame))

      # Load the CSV data file 
      csv = config['data']
      if not os.path.isfile(csv):
        csv = os.path.dirname(sys.argv[1]) + "/" + csv
      Data[frame] = mlab.csv2rec(csv, comments='None')

      # Read the list of metrics from the first frame (assumes all frames have the same metrics!)
      current_metrics = Data[frame].dtype.names[INDEX_FIRST_METRIC_CSV:INDEX_LAST_METRIC_CSV]
      # Filter the normalized metrics, we only plot the clustering dimensions and the extrapolated metrics
      Metrics[frame] = [m for m in current_metrics if isClusteringDimension(m) or isExtrapolatedMetric(m)]

      # Load the callers histogram        
      if 'callers' in config:
        histogram = config['callers']
        if not os.path.isfile(histogram):
          histogram = os.path.dirname(sys.argv[1]) + "/" + histogram
        # Ensure the histogram is not empty (may happen when all callers are unresolved)
        if (os.path.getsize(histogram) > SIZE_EMPTY_HISTOGRAM):
          Callers[frame] = mlab.csv2rec(histogram)

      # Read the number of tasks per trace
      trace = config['otrace']
      if not os.path.isfile(trace):
        trace = os.path.dirname(sys.argv[1]) + "/" + trace
      header = subprocess.Popen(["head", "-n1", trace], shell=False, stdout=subprocess.PIPE).communicate()[0]
      num_tasks = float(header.split("(")[2].split(":")[2])
      TasksPerFrame.append(num_tasks)

      # Save the trace files
      Traces.append(trace)
 
    self.FocusOnFrame   = 1
    self.FocusOnCluster = FirstCluster
    self.FocusOnMetric  = Metrics[self.FocusOnFrame][0]
    
    LastCluster         = np.max( Data[self.FocusOnFrame][CLUSTER_ID] )
    NumberOfClusters    = LastCluster - FirstCluster + 1

 
  def PlotCorrelation(self):
    for metric in Metrics[1]:
      if (self.DisplayingMetrics[metric] == True):
        metric_min = -1
        metric_max = -1
        avg_max    = -1
        metric_y   = [ ]
        for frame in range(1, NumberOfFrames+1):
          data = Data[frame][metric][Data[frame]['clusterid'] == self.FocusOnCluster]
          if (len(data) > 0):
            frame_min = nanmin( data )
            if ((frame_min < metric_min) or (metric_min == -1)):
              metric_min = frame_min
    
            frame_max = nanmax( data )
            if ((frame_max > metric_max) or (metric_max == -1)):
              metric_max = frame_max

        for frame in range(1, NumberOfFrames+1):
          data = Data[frame][metric][Data[frame]['clusterid'] == self.FocusOnCluster]
          if (len(data) > 0):
            frame_avg = nanmean( data )
            if ((frame_avg > avg_max) or (avg_max == -1)):
              avg_max = frame_avg

        for frame in range(1, NumberOfFrames+1):
          data = Data[frame][metric][Data[frame]['clusterid'] == self.FocusOnCluster]
          if (len(data) > 0):
            frame_avg = nanmean( data )
#            normalized_frame_avg = (frame_avg - metric_min) / (metric_max - metric_min)
#            normalized_frame_avg = (frame_avg / metric_max)
            if (avg_max == 0):
              normalized_frame_avg = 0
            else:
              normalized_frame_avg = (frame_avg / avg_max)
            metric_y.append( normalized_frame_avg )

        if (metric.lower() == self.FocusOnMetric.lower()):
          line_size = 3
        else:
          line_size = 1

        if (len(metric_y) > 1):
          self.AxesR1.plot (range(1, NumberOfFrames+1), metric_y, label=metric, lw=line_size, marker='o', ms=5, color=MetricColor(metric) )
        else:
          metric_x = np.linspace(1, NumberOfFrames, len(metric_y))
          self.AxesR1.scatter (metric_x, metric_y, label=metric, color=MetricColor(metric), s=50 )

    self.AxesR1.set_title('Region '+str(ClusterOffset(self.FocusOnCluster))+' all metrics evolution')
    self.AxesR1.set_xticks(range(1, NumberOfFrames+1))
    self.AxesR1.set_xlim(1, NumberOfFrames)
    self.AxesR1.set_xbound(1, NumberOfFrames)

    if (self.ToolbarR.GetToolState(self.ToolbarR.ON_LEGEND_CHECK) == True):
      metrics_list = Metrics[1]
      metrics_list = [m.upper()[2:] for m in metrics_list]
      self.AxesR1.legend(map(lambda x:x.upper(), metrics_list), loc=(0,0), prop={'size':7})

    
  # def PlotHeatmap(self):
  #   dim_x = self.XDimension()
  #   dim_y = self.YDimension()

  #   heatm_precision = 50
  #   heatm_num_ticks = 5

  #   xdata = Data[self.FocusOnFrame][dim_x]
  #   ydata = Data[self.FocusOnFrame][dim_y]
    
  #   heatm_x = xdata[np.isfinite(xdata)]
  #   heatm_y = ydata[np.isfinite(ydata)]

  #   heatmap, heatm_xedges, heatm_yedges = np.histogram2d(heatm_x, heatm_y, bins=heatm_precision)
  #   extent = [heatm_xedges[0], heatm_xedges[-1], heatm_yedges[0], heatm_yedges[-1]]

  #   cax = self.AxesL.imshow(heatmap, origin='lower', aspect='auto', extent=extent)
  #   self.ColorBar = self.FigL.colorbar(cax, ax=self.AxesL, orientation='vertical', use_gridspec=True, shrink=0.8)
    

  def PlotDispersion(self):
    metric_dispersion = [ ]
    metric_average    = [ ]
    metric_min        = [ ]
    metric_max        = [ ]
    for frame in range(1, NumberOfFrames+1):
      frame_dispersion = Data[frame][self.FocusOnMetric][Data[frame]['clusterid'] == self.FocusOnCluster]
      if (len(frame_dispersion) > 0):
        metric_dispersion.append( frame_dispersion[np.isfinite(frame_dispersion)] )
        metric_average.append( nanmean(Data[frame][self.FocusOnMetric][Data[frame]['clusterid'] == self.FocusOnCluster]) )
        metric_min.append( nanmin(Data[frame][self.FocusOnMetric][Data[frame]['clusterid'] == self.FocusOnCluster]) )
        metric_max.append( nanmax(Data[frame][self.FocusOnMetric][Data[frame]['clusterid'] == self.FocusOnCluster]) )
  
    self.AxesR2.set_title('Region '+str(ClusterOffset(self.FocusOnCluster))+' '+self.FocusOnMetric.upper()[2:]+' evolution')
    if (len(metric_dispersion) > 1):
      if (self.ToolbarR.GetToolState(self.ToolbarR.ON_BOXPLOT_CHECK) == True):
        self.AxesR2.boxplot(metric_dispersion)
        self.AxesR2.plot( range(1, NumberOfFrames+1), metric_average, lw=2, marker='o', ms=5, color=MetricColor(self.FocusOnMetric) )
      else:
        x = range(1, NumberOfFrames+1)
        self.AxesR2.plot(x, metric_min, ls='--', color=MetricColor(self.FocusOnMetric))
        self.AxesR2.plot(x, metric_average, marker='o', ms=5, label=self.FocusOnMetric.upper()[2:], color=MetricColor(self.FocusOnMetric))
        self.AxesR2.plot(x, metric_max, ls='--', color=MetricColor(self.FocusOnMetric))
        self.AxesR2.fill_between(x, metric_min, metric_max, alpha=0.25, color=MetricColor(self.FocusOnMetric) )
    else:
      metric_x = np.linspace(1, NumberOfFrames, len(metric_average))
      self.AxesR2.scatter (metric_x, metric_average, label=self.FocusOnMetric.upper()[2:], color=MetricColor(self.FocusOnMetric), s=50 )

    self.AxesR2.set_xticks(range(1, NumberOfFrames+1))
    self.AxesR2.set_xlim(1, NumberOfFrames)
    self.AxesR2.set_xbound(1, NumberOfFrames)

    if (self.GetFittingSamples() > 0):
      fit_x, fit_y, fit_label = self.Predict(metric_average)
      self.AxesR2.plot(fit_x, fit_y, ls=':', color='black', label='Fitting curve', marker='o', ms=4)
      self.AxesR2.set_xticks(range(1, len(fit_x)+1))
      self.AxesR2.set_xlim(1, len(fit_x))
      self.AxesR2.set_xbound(1, len(fit_x))
      self.FittingLabel.SetLabel( fit_label )
    else:
      self.FittingLabel.SetLabel( '' ) 

    if (self.ToolbarR.GetToolState(self.ToolbarR.ON_LEGEND_CHECK) == True):
      metrics_list = Metrics[1]
      metrics_list = [m.upper()[2:] for m in metrics_list]
      self.AxesR2.legend(loc=(0,0), prop={'size':7})


  def Predict(self, y):
    x = range(1, len(y)+1)

    x = [float(xn) for xn in x]
    y = [float(yn) for yn in y]
    x = np.array(x)
    y = np.array(y)

    type = self.RegressionModelCombo.GetSelection()

    if (type == FITTING_POLY_1):
      popt, pcov = curve_fit(fitting_poly_1, x, y)
      func = fitting_poly_1
      fit_label = "f(x)="+str("%.2f" % popt[0])+"*x+"+str("%.2f" % popt[1])
    elif (type == FITTING_POLY_2):
      popt, pcov = curve_fit(fitting_poly_2, x, y)
      func = fitting_poly_2
      fit_label = "f(x)="+str("%.2f" % popt[0])+"*x^2+"+str("%.2f" % popt[1])+"*x+"+str("%.2f" % popt[2])
    elif (type == FITTING_POLY_3):
      popt, pcov = curve_fit(fitting_poly_3, x, y)
      func = fitting_poly_3
      fit_label = "f(x)="+str("%.2f" % popt[0])+"*x^3+"+str("%.2f" % popt[1])+"*x^2+"+str("%.2f" % popt[2])+"*x+"+str("%.2f" % popt[3])
    elif (type == FITTING_LOG):
      popt, pcov = curve_fit(fitting_log, x, y)
      func = fitting_log
      fit_label = "f(x)="+str("%.2f" % popt[0])+"*log(x)+"+str("%.2f" % popt[1])
    elif (type == FITTING_LIN_LOG):
      popt, pcov = curve_fit(fitting_lin_log, x, y)
      func = fitting_lin_log
      fit_label = "f(x)="+str("%.2f" % popt[0])+"*x*log(x)+"+str("%.2f" % popt[1])
    else:
      popt, pcov = curve_fit(fitting_poly_1, x, y)
      func = fitting_poly_1
      fit_label = "f(x)="+str("%.2f" % popt[0])+"*x+"+str("%.2f" % popt[1])


    fit_x = range(1, NumberOfFrames + self.GetFittingSamples() + 1)
    fit_y = [ ]
    for x in fit_x:
      fit_y.append( func(x, *popt) )

    fit_label = fit_label.replace("+-", "-")
    return fit_x, fit_y, fit_label

  # def Predict(self, y):
  #   x = range(1, len(y)+1)
   
  #   fit = np.polyfit(x, y, self.GetFittingDegree())
  #   fit_fn = np.poly1d(fit) # fit_fn is now a function which takes in x and returns an estimate for y

  #   fit_x = range(1, NumberOfFrames + self.GetFittingSamples() + 1)
  #   fit_y = [ ]
  #   for x in fit_x:
  #     fit_y.append( fit_fn(x) )

  #   return fit_x, fit_y, ''

  def GetFittingSamples(self):
    return int(self.PredictExperiments.GetValue())

  def GetFittingDegree(self):
    return self.RegressionModelCombo.GetSelection() + 1


  # def on_Resolution_Change(self, event):
  #   self.Bins = self.ResolutionSlider.GetValue()
  #   self.PlotR()

  def XDimension(self):
    idx = self.XAxisCombo.GetSelection()
    return Metrics[1][idx]    

  def YDimension(self):
    idx = self.YAxisCombo.GetSelection()
    return Metrics[1][idx]    

  def ZDimension(self):
    idx = self.ZAxisCombo.GetSelection()
    return Metrics[1][idx]    

  def PlotL(self):
    self.AxesL.clear()
    self.FigL.clf()
    if (self.in_3D() == True):
      self.AxesL = self.FigL.add_subplot(111, projection='3d')
    else:
      self.AxesL = self.FigL.add_subplot(111)

    self.Compute_Scatters()
    self.Compute_Scaled_Scatters()
    self.Compute_Ranges()

    self.Display_Objects()
    self.Set_Scales()

    self.CanvasL.draw()

  def PlotR(self):
    self.FigR.clf()
    self.AxesR1 = self.FigR.add_subplot(211)
    self.AxesR2 = self.FigR.add_subplot(212)
    self.AxesR1.ticklabel_format(style='sci', scilimits=(0,0), axis='both') 
    self.AxesR2.ticklabel_format(style='sci', scilimits=(0,0), axis='both') 
    self.AxesR1.set_ylabel("Normalized value")
    self.AxesR2.set_xlabel("Frame")
    self.AxesR2.set_ylabel(str(self.FocusOnMetric).upper()[2:])

    self.PlotCorrelation()
    self.PlotDispersion()
#    self.FigR.tight_layout()
    self.CanvasR.draw()


  def Compute_Ranges(self):
    self.XRange       = defaultdict()
    self.YRange       = defaultdict()
    self.ZRange       = defaultdict()
    self.XRangeScaled = defaultdict()
    self.YRangeScaled = defaultdict()
    self.ZRangeScaled = defaultdict()

    dim_x = self.XDimension()
    dim_y = self.YDimension()
    if (self.in_3D() == True):
      dim_z = self.ZDimension()

    X_local_min = []
    X_local_max = []
    Y_local_min = []
    Y_local_max = []
    Z_local_min = []
    Z_local_max = []

    for frame in range(1, NumberOfFrames+1):
      X_local_min.append( nanmin(Data[frame][dim_x]) )
      X_local_max.append( nanmax(Data[frame][dim_x]) )
      Y_local_min.append( nanmin(Data[frame][dim_y]) )
      Y_local_max.append( nanmax(Data[frame][dim_y]) )
      if self.in_3D():
        Z_local_min.append( nanmin(Data[frame][dim_z]) )
        Z_local_max.append( nanmax(Data[frame][dim_z]) )

    X_local_min_scaled = np.array(X_local_min) * np.array(TasksPerFrame)
    X_local_max_scaled = np.array(X_local_max) * np.array(TasksPerFrame)
    FrameWithMinX = X_local_min_scaled.argmin() 
    FrameWithMaxX = X_local_max_scaled.argmax() 
    Y_local_min_scaled = np.array(Y_local_min) * np.array(TasksPerFrame)
    Y_local_max_scaled = np.array(Y_local_max) * np.array(TasksPerFrame)
    FrameWithMinY = Y_local_min_scaled.argmin() 
    FrameWithMaxY = Y_local_max_scaled.argmax() 

    if self.in_3D():
      Z_local_min_scaled = np.array(Z_local_min) * np.array(TasksPerFrame)
      Z_local_max_scaled = np.array(Z_local_max) * np.array(TasksPerFrame)
      FrameWithMinZ = Z_local_min_scaled.argmin() 
      FrameWithMaxZ = Z_local_max_scaled.argmax() 

    XMinRatioPerFrame = []
    YMinRatioPerFrame = []
    ZMinRatioPerFrame = []

    XMaxRatioPerFrame = []
    YMaxRatioPerFrame = []
    ZMaxRatioPerFrame = []
    for frame in range(1, NumberOfFrames+1):

      ### Compute the ratios for the current trace with respect to the min/max values for this dimension
      XMinRatioPerFrame.append( TasksPerFrame[ FrameWithMinX ] / TasksPerFrame[ frame-1 ] )
      YMinRatioPerFrame.append( TasksPerFrame[ FrameWithMinY ] / TasksPerFrame[ frame-1 ] )
      if self.in_3D():
        ZMinRatioPerFrame.append( TasksPerFrame[ FrameWithMinZ ] / TasksPerFrame[ frame-1 ] )

      XMaxRatioPerFrame.append( TasksPerFrame[ FrameWithMaxX ] / TasksPerFrame[ frame-1 ] )
      YMaxRatioPerFrame.append( TasksPerFrame[ FrameWithMaxY ] / TasksPerFrame[ frame-1 ] )
      if self.in_3D():
        ZMaxRatioPerFrame.append( TasksPerFrame[ FrameWithMaxZ ] / TasksPerFrame[ frame-1 ] )

      ### Normalize the mins/maxs per trace with respect to the ratios
      self.XRangeScaled[frame] = ( X_local_min[ FrameWithMinX ] * XMinRatioPerFrame[frame-1], X_local_max[ FrameWithMaxX ] * XMaxRatioPerFrame[frame-1] )
      self.YRangeScaled[frame] = ( Y_local_min[ FrameWithMinY ] * YMinRatioPerFrame[frame-1], Y_local_max[ FrameWithMaxY ] * YMaxRatioPerFrame[frame-1] )
      if self.in_3D():
        self.ZRangeScaled[frame] = ( Z_local_min[ FrameWithMinZ ] * ZMinRatioPerFrame[frame-1], Z_local_max[ FrameWithMaxZ ] * ZMaxRatioPerFrame[frame-1] )

      ### Store the global ranges
      self.XRange[frame] = ( np.min( X_local_min ), np.max( X_local_max ) )
      self.YRange[frame] = ( np.min( Y_local_min ), np.max( Y_local_max ) )
      if self.in_3D():
        self.ZRange[frame] = ( np.min( Z_local_min ), np.max( Z_local_max ) )
      else:
        self.ZRange[frame] = (0, 0)

    self.XRangeGlobal = ( np.min( X_local_min ), np.max( X_local_max ) )
    self.YRangeGlobal = ( np.min( Y_local_min ), np.max( Y_local_max ) )
    if self.in_3D():
      self.ZRangeGlobal = ( np.min( Z_local_min ), np.max( Z_local_max ) )
 
    self.XRangeGlobalScaled = ( np.min( X_local_min_scaled ), np.max( X_local_max_scaled ) )
    self.YRangeGlobalScaled = ( np.min( Y_local_min_scaled ), np.max( Y_local_max_scaled ) )
    if self.in_3D():
      self.ZRangeGlobalScaled = ( np.min( Z_local_min_scaled ), np.max( Z_local_max_scaled ) )

  def Set_Scales(self):

    if (self.CurrentView == VIEW_TRACKING) and (self.NowShowing == SHOW_OBJECTS_SCALED):
      if (self.ScaleState[X] == True): 
        self.AxesL.set_xlim( self.XRangeGlobalScaled )
      else:
        self.AxesL.set_xlim( self.XRangeGlobal )
      if (self.ScaleState[Y] == True):
        self.AxesL.set_ylim( self.YRangeGlobalScaled )
      else:
        self.AxesL.set_ylim( self.YRangeGlobal )
      if self.in_3D():
        if (self.ScaleState[Z] == True):
          self.AxesL.set_zlim( self.ZRangeGlobalScaled )
        else:
          self.AxesL.set_zlim( self.ZRangeGlobal )

    else:
      if (self.ScaleState[X] == True):
        self.AxesL.set_xlim( self.XRangeScaled[self.FocusOnFrame][0], self.XRangeScaled[self.FocusOnFrame][1] )
      else:
        self.AxesL.set_xlim( self.XRange[self.FocusOnFrame][0], self.XRange[self.FocusOnFrame][1] )

      if (self.ScaleState[Y] == True):
        self.AxesL.set_ylim( self.YRangeScaled[self.FocusOnFrame][0], self.YRangeScaled[self.FocusOnFrame][1] )
      else:
        self.AxesL.set_ylim( self.YRange[self.FocusOnFrame][0], self.YRange[self.FocusOnFrame][1] )
 
      if self.in_3D():
        if (self.ScaleState[Z] == True):
          self.AxesL.set_zlim( self.ZRangeScaled[self.FocusOnFrame][0], self.ZRangeScaled[self.FocusOnFrame][1] )
        else:
          self.AxesL.set_zlim( self.ZRange[self.FocusOnFrame][0], self.ZRange[self.FocusOnFrame][1] )



    if self.in_2D():
      if (self.LogState[X] == True):
        self.AxesL.set_xscale('log')
      else:
        self.AxesL.set_xscale('linear')
      if (self.LogState[Y] == True):
        self.AxesL.set_yscale('log')
      else:
        self.AxesL.set_yscale('linear')
    else:
      if (self.LogState[X] == True):
        self.AxesL.xaxis.set_scale('log')
      else:
        self.AxesL.xaxis.set_scale('linear')
      if (self.LogState[Y] == True):
        self.AxesL.yaxis.set_scale('log')
      else:
        self.AxesL.yaxis.set_scale('linear')
      if (self.LogState[Z] == True) and (self.in_3D()):
        self.AxesL.zaxis.set_scale('log')
      else:
        self.AxesL.zaxis.set_scale('linear')

    if not self.LogState[X]:
      xlim = self.AxesL.get_xlim()
      self.AxesL.set_xlim( xlim[0] - (xlim[1] * 0.05), xlim[1] + (xlim[1] * 0.05) )
    if not self.LogState[Y]:
      ylim = self.AxesL.get_ylim()
      self.AxesL.set_ylim( ylim[0] - (ylim[1] * 0.05), ylim[1] + (ylim[1] * 0.05) )
    if not self.LogState[Z]:
      if self.in_3D():
        zlim = self.AxesL.get_zlim()
        self.AxesL.set_zlim( zlim[0] - (zlim[1] * 0.05), zlim[1] + (zlim[1] * 0.05) )

    #
    # Configure axes labels
    # 
    self.AxesL.set_xlabel( self.XAxisCombo.GetValue() )
    self.AxesL.set_ylabel( self.YAxisCombo.GetValue() )
    if (self.in_3D() == True):
      self.AxesL.set_zlabel( self.ZAxisCombo.GetValue() )

    if not self.LogState[X] and not self.LogState[Y]:
      self.AxesL.ticklabel_format(style='sci', scilimits=(0,0), axis='both') 

  def Compute_Scaled_Scatters(self):
   
    if self.ScaleState[X] or self.ScaleState[Y] or self.ScaleState[Z]:
      self.ObjectsScaled.clear()
      self.ObjectsScaled = self.Compute_Objects( self.ScaleState[X], self.ScaleState[Y], self.ScaleState[Z] )
   
  def Compute_Scatters(self):

    self.Objects.clear()
    self.Objects = self.Compute_Objects( False, False, False )

  def Compute_Objects(self, scale_x, scale_y, scale_z):
    AllObjects   = defaultdict()
    Scatters     = defaultdict()
    Hulls        = defaultdict()
    Centroids    = defaultdict()
    Trajectories = defaultdict()
    Arrows       = defaultdict(list)

    dim_x = self.XDimension()
    dim_y = self.YDimension()
    if self.in_3D():
      dim_z = self.ZDimension()

    for frame in range(1, NumberOfFrames+1):
      for cluster_id in range(FirstCluster, LastCluster+1):
        ClusterData = Data[frame][Data[frame][CLUSTER_ID] == cluster_id]
        if (len(ClusterData) == 0): continue

        xdata = ClusterData[dim_x]
        if scale_x:
          xdata = xdata * TasksPerFrame[frame-1]
        ydata = ClusterData[dim_y]
        if scale_y:
          ydata = ydata * TasksPerFrame[frame-1]
        if self.in_3D():
          zdata = ClusterData[dim_z]
          if scale_x:
            zdata = zdata * TasksPerFrame[frame-1]

        #
        # Compute the scatter plot for this cluster
        #
        if self.in_3D():
          cluster_scatter = self.AxesL.scatter( xdata, ydata, zdata, color=PRVColor(cluster_id), zorder=2, s=50, marker=ChooseMarker(cluster_id))
        else:
          cluster_scatter = self.AxesL.scatter( xdata, ydata, color=PRVColor(cluster_id), zorder=2, s=50, marker=ChooseMarker(cluster_id))
        cluster_scatter.set_visible(False)
        Scatters[(cluster_id, frame)] = cluster_scatter

        # 
        # Compute the centroid for this cluster
        # 
        centroid_x = nanmean( xdata )
        centroid_y = nanmean( ydata )
        if self.in_3D():
          centroid_z = nanmean( zdata )
          cluster_centroid = self.AxesL.scatter(centroid_x, centroid_y, centroid_z, s=50, color=PRVColor(cluster_id), edgecolor="black", marker="o", zorder=3)
          Trajectories[(cluster_id, frame)] = (centroid_x, centroid_y, centroid_z)
        else:
          cluster_centroid = self.AxesL.scatter(centroid_x, centroid_y, s=50, color=PRVColor(cluster_id), edgecolor="black", marker="o", zorder=3)
          Trajectories[(cluster_id, frame)] = (centroid_x, centroid_y)
        cluster_centroid.set_visible(False)
        Centroids[(cluster_id, frame)] = cluster_centroid

        #
        # Compute the convex hull for this cluster
        #
        if CanDoHulls and self.in_2D():
          try:
            XY = np.array(zip(xdata, ydata))
            hull  = qhull.Delaunay(XY).convex_hull
          except Exception, err:
            print "xtrack: Error computing hull for cluster", cluster_id, ", frame", frame, "!"
            #print traceback.format_exc()
            continue
          g = csr_matrix((np.ones(hull.shape[0]),hull.T), shape=(hull.max()+1,)*2)
          sorted_hull = csgraph.depth_first_order(g,hull[0,0],directed=False)[0]

          hull_open_x = np.array(XY[sorted_hull,0])
          hull_open_y = np.array(XY[sorted_hull,1])
          hull_closed_x = np.append(hull_open_x, hull_open_x[0])
          hull_closed_y = np.append(hull_open_y, hull_open_y[0])

          vertices = zip(hull_closed_x, hull_closed_y)
          cluster_hull = Polygon(vertices, True, color=PRVColor(cluster_id), zorder=1)
          cluster_hull.set_visible(False)
          self.AxesL.add_artist( cluster_hull )
          Hulls[(cluster_id, frame)] = cluster_hull

    # Compute the arrows for the trajectories
    for cluster_id in range(FirstCluster, LastCluster+1):

      from_frame = 1
      to_frame   = from_frame + 1
      while (to_frame <= NumberOfFrames):
        tail = (cluster_id, from_frame)
        head = (cluster_id, to_frame)

        if not tail in Trajectories:
          from_frame = to_frame
          to_frame   = from_frame +1
          continue
        else:
          if not head in Trajectories:
            to_frame = to_frame + 1
            continue

        from_x = Trajectories[tail][0]
        from_y = Trajectories[tail][1]
        to_x   = Trajectories[head][0]
        to_y   = Trajectories[head][1]
        if self.in_3D():
          from_z = Trajectories[tail][2]
          to_z   = Trajectories[head][2]

        if (not (math.isnan(from_x) or math.isnan(from_y) or math.isnan(to_x) or math.isnan(to_y))):
          if (self.in_3D() and (not (math.isnan(from_z) or math.isnan(to_z)))):
            arrow = Arrow3D((from_x,to_x), (from_y, to_y), (from_z, to_z), arrowstyle='-|>', mutation_scale=20, color=PRVColor(cluster_id), linewidth=1)
          else:
            arrow = FancyArrowPatch((from_x,from_y), (to_x,to_y), arrowstyle='-|>', mutation_scale=20, color=PRVColor(cluster_id), linewidth=1)
          arrow.set_visible(False)
          Arrows[cluster_id].append(arrow)
          self.AxesL.add_artist(arrow)

        from_frame = to_frame
        to_frame   = from_frame +1

    # Compute the interpolated trajectory
    self.AnimationSeconds = 0.0001
    self.AnimationSamples = 25
    self.AnimationPeriod  = float(self.AnimationSeconds / self.AnimationSamples)
    self.T = np.linspace(0, NumberOfFrames, self.AnimationSamples)

    Paths = defaultdict()
    Xi    = defaultdict()
    Yi    = defaultdict()
    Zi    = defaultdict()

    for cluster_id in range(FirstCluster, LastCluster+1):
      Xs = []
      Ys = []
      Zs = []
      for frame in range(1, NumberOfFrames+1):
        # Sequence of X and Y coords for this object 
        if (cluster_id, frame) in Trajectories:
          Xs.append( Trajectories[(cluster_id, frame)][0] )
          Ys.append( Trajectories[(cluster_id, frame)][1] )
          if self.in_3D():
            Zs.append( Trajectories[(cluster_id, frame)][2] )

      if (len(Xs) > 1 and len(Ys) > 1 and self.in_2D()) or (len(Xs) > 1 and len(Ys) > 1 and len(Zs) > 1):
        Ts = np.linspace(0, len(Xs), len(Xs))

        # Generate the interpolated array
        fx = interp1d(Ts, Xs, kind="linear")
        fy = interp1d(Ts, Ys, kind="linear")
        Xi[cluster_id] = fx(self.T)
        Yi[cluster_id] = fy(self.T)
        if self.in_3D():
          fz = interp1d(Ts, Zs, kind="linear")
          Zi[cluster_id] = fz(self.T)

        # Artists for the interpolated path
        if self.in_2D():
          Path = Line2D([], [], color='black')
          Tail = Line2D([], [], color='red', linewidth=3)
          Head = Line2D([], [], color='red', marker='o', markeredgecolor='black')
        else:
          Path = Line3D([], [], [], color='black')
          Tail = Line3D([], [], [], color='red', linewidth=3)
          Head = Line3D([], [], [], color='red', marker='o', markeredgecolor='black')       
        Path.set_visible(False)
        Tail.set_visible(False)
        Head.set_visible(False)
        self.AxesL.add_line(Path)
        self.AxesL.add_line(Tail)
        self.AxesL.add_line(Head)
        Paths[cluster_id] = (Path, Tail, Head)

    AllObjects['scatters']     = Scatters
    AllObjects['centroids']    = Centroids
    AllObjects['arrows']       = Arrows
    AllObjects['hulls']        = Hulls
    AllObjects['paths']        = Paths
    AllObjects['xi']           = Xi
    AllObjects['yi']           = Yi
    if self.in_3D():
      AllObjects['zi']           = Zi
    return AllObjects


  def Display_Scatters(self):
    if 'scatters' in self.ShowingObjects:
      for (cluster_id, frame) in self.ShowingObjects['scatters']:
        if (self.DisplayingClusters[cluster_id]):
          scatter = self.ShowingObjects['scatters'][(cluster_id, frame)]
          draw_this_frame = (self.CurrentView == VIEW_TRACKING) or (frame == self.FocusOnFrame)
          if (self.ToolbarL.GetToolState(self.ToolbarL.ON_SCATTER_CHECK) == True) and (draw_this_frame):
            scatter.set_visible(True)
          else:
            scatter.set_visible(False)

  def Display_Centroids(self):
    if 'centroids' in self.ShowingObjects:
      for (cluster_id, frame) in self.ShowingObjects['centroids']:
        if (self.DisplayingClusters[cluster_id]):
          centroid = self.ShowingObjects['centroids'][(cluster_id, frame)]
          draw_this_frame = (self.CurrentView == VIEW_TRACKING) or (frame == self.FocusOnFrame)
          if (self.ToolbarL.GetToolState(self.ToolbarL.ON_CENTROID_CHECK) == True) and (draw_this_frame):
            centroid.set_visible(True)
          else:
            centroid.set_visible(False)

  def Display_Hulls(self):
    if 'hulls' in self.ShowingObjects:
      for (cluster_id, frame) in self.ShowingObjects['hulls']:
        if (self.DisplayingClusters[cluster_id]):
          hull = self.ShowingObjects['hulls'][(cluster_id, frame)]
          draw_this_frame = (self.CurrentView == VIEW_TRACKING) or (frame == self.FocusOnFrame)
          if (self.ToolbarL.GetToolState(self.ToolbarL.ON_HULL_CHECK) == True) and (draw_this_frame):
            hull.set_visible(True)
          else:
            hull.set_visible(False)

  def Display_Arrows(self):
    if 'arrows' in self.ShowingObjects:
      for cluster_id in range(FirstCluster, LastCluster+1):
        if (self.DisplayingClusters[cluster_id] == True):
          for arrow in self.ShowingObjects['arrows'][cluster_id]:
            arrow.set_visible(True)

  def Display_Paths(self):
    if 'paths' in self.ShowingObjects:
      for obj in self.ShowingObjects['paths']:
        (path, head, tail) = self.ShowingObjects['paths'][obj]
        path.set_visible(True)
        head.set_visible(True)
        tail.set_visible(True)


  def Hide_Objects(self, objects_to_hide):
    if ((objects_to_hide == HIDE_SCATTERS) or (objects_to_hide == HIDE_ALL)) and ('scatters' in self.ShowingObjects):
      for obj in self.ShowingObjects['scatters']:
        self.ShowingObjects['scatters'][obj].set_visible(False)
    if ((objects_to_hide == HIDE_CENTROIDS) or (objects_to_hide == HIDE_ALL)) and ('centroids' in self.ShowingObjects):
      for obj in self.ShowingObjects['centroids']:
        self.ShowingObjects['centroids'][obj].set_visible(False)
    if ((objects_to_hide == HIDE_HULLS) or (objects_to_hide == HIDE_ALL)) and ('hulls' in self.ShowingObjects):
      for obj in self.ShowingObjects['hulls']:
        self.ShowingObjects['hulls'][obj].set_visible(False)
    if ((objects_to_hide == HIDE_ARROWS) or (objects_to_hide == HIDE_ALL)) and ('arrows' in self.ShowingObjects):
      for obj in self.ShowingObjects['arrows']:
        for arrow in self.ShowingObjects['arrows'][obj]:
          arrow.set_visible(False)
    if ((objects_to_hide == HIDE_PATHS) or (objects_to_hide == HIDE_ALL)) and ('paths' in self.ShowingObjects):
      for obj in self.ShowingObjects['paths']:
        (path, head, tail) = self.ShowingObjects['paths'][obj]
        path.set_visible(False)
        head.set_visible(False)
        tail.set_visible(False)

  def Display_Objects(self):
    self.Hide_Objects(HIDE_ALL)

    self.Select_Objects()

    self.Display_Scatters()
    self.Display_Centroids()
    self.Display_Hulls()

    if (self.CurrentView == VIEW_TRACKING):
      self.Display_Arrows()
      self.AxesL.set_title("Trajectories")
    else:
      self.AxesL.set_title("Frame "+str(self.FocusOnFrame))


  def EnableControls(self):
    self.AxesSwapButton.Enable()
    self.Activate3DButton.Enable()
    self.XAxisCombo.Enable()
    self.YAxisCombo.Enable()
    self.XAxisLogButton.Enable()
    self.YAxisLogButton.Enable()
    self.XAxisScaleButton.Enable()
    self.YAxisScaleButton.Enable()
    if self.in_3D():
      self.ZAxisCombo.Enable()
      self.ZAxisLogButton.Enable()
      self.ZAxisScaleButton.Enable()
    if (self.CurrentView != VIEW_TRACKING):
      self.PrevButton.Enable()
      self.NextButton.Enable()
      self.FrameSlider.Enable()
      self.TimelineButton.Enable()
    self.PlayButton.Enable()
    self.TrackingButton.Enable()
    self.ClustersScroll.Enable()
    self.MetricsScroll.Enable()

  def DisableControls(self):
    self.AxesSwapButton.Disable()
    self.Activate3DButton.Disable()
    self.XAxisCombo.Disable()
    self.YAxisCombo.Disable()
    self.ZAxisCombo.Disable()
    self.XAxisLogButton.Disable()
    self.YAxisLogButton.Disable()
    self.ZAxisLogButton.Disable()
    self.XAxisScaleButton.Disable()
    self.YAxisScaleButton.Disable()
    self.ZAxisScaleButton.Disable()
    self.PrevButton.Disable()
    self.NextButton.Disable()
    self.PlayButton.Disable()
    self.FrameSlider.Disable()
    self.TimelineButton.Disable()
    self.TrackingButton.Disable()
    self.ClustersScroll.Disable()
    self.MetricsScroll.Disable()


  def on_Playing_Timer(self, event):
    self.FocusOnFrame = self.PlayingCurrentFrame
    self.FrameSlider.SetValue(self.PlayingCurrentFrame)
    self.Display_Objects()
    self.Set_Scales()
    self.CanvasL.draw()
    self.PlayingCurrentFrame = self.PlayingCurrentFrame + 1
    if (self.PlayingCurrentFrame > NumberOfFrames):
      self.PlayTimer.Stop()
      self.EnableControls()
    else:
      self.PlayTimer.Start(1000, oneShot=True)


  def on_Metrics_Display(self, event):
    btn = event.GetEventObject()
    metric = btn.GetName()
    if (self.DisplayingMetrics[ metric ] == True):
      self.DisplayingMetrics[ metric ] = False
      bmp = self.bmp_nodisplay
    else:
      self.DisplayingMetrics[ metric ] = True
      bmp = self.bmp_display

    for controls in self.MetricsScrollList:
      if (controls[0].GetName() == metric):
        controls[0].SetBitmapLabel(bmp)
        break
    self.PlotR()

  def on_Metrics_Focus(self, event):

    btn = event.GetEventObject()
    self.set_Metric_Focus( btn.GetName() )
    self.PlotR()

  def set_Metric_Focus(self, metric):
    for controls in self.MetricsScrollList:
      if (controls[1].GetName() == metric):
        controls[1].SetValue(1)
        controls[1].SetBackgroundColour(wx.Colour(Color_Selected[0]*255, Color_Selected[1]*255, Color_Selected[2]*255, 0))
        self.FocusOnMetric = metric
      else:
        controls[1].SetValue(0)
        controls[1].SetBackgroundColour(wx.Colour(Color_NonSelected[0]*255, Color_NonSelected[1]*255, Color_NonSelected[2]*255, 0))

  def on_Clusters_Display(self, event):
    btn = event.GetEventObject()
    cluster_id = int(btn.GetName())
    if (self.DisplayingClusters[ cluster_id ] == True):
      self.DisplayingClusters[ cluster_id ] = False
      bmp = self.bmp_nodisplay
    else:
      self.DisplayingClusters[ cluster_id ] = True
      bmp = self.bmp_display

    for controls in self.ClustersScrollList:
      if (int(controls[0].GetName()) == cluster_id):
        controls[0].SetBitmapLabel(bmp)
        break
    self.Display_Objects()
    self.CanvasL.draw()

  def on_Clusters_Focus(self, event):
    btn = event.GetEventObject()
    self.set_Cluster_Focus(btn.GetName())
    self.PlotR()

  def set_Cluster_Focus(self, cluster_id):
    for controls in self.ClustersScrollList:
      if (controls[1].GetName() == str(cluster_id)):
        controls[1].SetValue(1)
        controls[1].SetBackgroundColour(wx.Colour(Color_Selected[0]*255, Color_Selected[1]*255, Color_Selected[2]*255, 0))
        self.FocusOnCluster = int(cluster_id)
      else:
        controls[1].SetValue(0)
        controls[1].SetBackgroundColour(wx.Colour(Color_NonSelected[0]*255, Color_NonSelected[1]*255, Color_NonSelected[2]*255, 0))





  def _draw_frame(self, current_frame):
    i = current_frame
    head = i - 1
    head_len = 0.5

    for cluster_id in self.ShowingObjects['paths']:
      if (self.DisplayingClusters[cluster_id] == True):
        x = self.ShowingObjects['xi'][cluster_id]
        y = self.ShowingObjects['yi'][cluster_id]
        if self.in_3D():
          z = self.ShowingObjects['zi'][cluster_id]

        Path = self.ShowingObjects['paths'][cluster_id][0]
        Tail = self.ShowingObjects['paths'][cluster_id][1]
        Head = self.ShowingObjects['paths'][cluster_id][2]

        # Status of this frame for each object
        head_slice = (self.T > self.T[i] - head_len) & (self.T < self.T[i])

        Path.set_data(x[:i], y[:i])
        Tail.set_data(x[head_slice], y[head_slice])
        Head.set_data(x[head], y[head])
        if self.in_3D():
          Path.set_3d_properties(z[:i])
          Tail.set_3d_properties(z[head_slice])
          Head.set_3d_properties(z[head])

        # Display the trajectory animation
        self._drawn_artists.append(Path)
        self._drawn_artists.append(Tail)
        self._drawn_artists.append(Head) 
    if (current_frame+1 == self.AnimationSamples):
      self.EnableControls()
      self.Hide_Objects(HIDE_PATHS)

  def new_frame_seq(self):
    return iter(range(self.AnimationSamples))

  def _init_draw(self):
    for cluster_id in self.ShowingObjects['paths']:
      (path, head, tail) = [self.ShowingObjects['paths'][cluster_id][0], self.ShowingObjects['paths'][cluster_id][1], self.ShowingObjects['paths'][cluster_id][2]]
      path.set_data([], [])
      head.set_data([], [])
      tail.set_data([], [])
      if self.in_3D():
        path.set_3d_properties([])
        head.set_3d_properties([])
        tail.set_3d_properties([])

  def in_3D(self):
    return self.Activate3DButton.GetValue()

  def in_2D(self):
    return not self.in_3D()

  #
  # Triggers
  # 
  def on_XAxisCombo_Change(self, event):
    self.PlotL()

  def on_YAxisCombo_Change(self, event):
    self.PlotL()

  def on_ZAxisCombo_Change(self, event):
    self.PlotL()

  def on_Swap_Button(self, event):
    old_x       = self.XAxisCombo.GetSelection()
    old_y       = self.YAxisCombo.GetSelection()
    old_log_x   = self.LogState[X]
    old_log_y   = self.LogState[Y]
    old_scale_x = self.ScaleState[X]
    old_scale_y = self.ScaleState[Y]
    self.XAxisCombo.SetSelection( old_y )
    self.YAxisCombo.SetSelection( old_x )
    if (old_log_x == 1):
      self.YAxisLogButton.SetBitmapLabel(self.bmp_log_on)
    else:
      self.YAxisLogButton.SetBitmapLabel(self.bmp_log_off)
    if (old_log_y == 1):
      self.XAxisLogButton.SetBitmapLabel(self.bmp_log_on)
    else:
      self.XAxisLogButton.SetBitmapLabel(self.bmp_log_off)
    if (old_scale_x == 1):
      self.YAxisScaleButton.SetBitmapLabel(self.bmp_scale_on)
    else:
      self.YAxisScaleButton.SetBitmapLabel(self.bmp_scale_off)
    if (old_scale_y == 1):
      self.XAxisScaleButton.SetBitmapLabel(self.bmp_scale_on)
    else:
      self.XAxisScaleButton.SetBitmapLabel(self.bmp_scale_off)
    self.LogState[X]   = old_log_y
    self.LogState[Y]   = old_log_x
    self.ScaleState[X] = old_scale_y
    self.ScaleState[Y] = old_scale_x
    self.PlotL()

  def on_3D_Button(self, event):
    if (self.Activate3DButton.GetValue() == True):
      self.ZAxisCombo.Enable()
      self.ZAxisLogButton.Enable()
      self.ZAxisScaleButton.Enable()
      self.ToolbarL.EnableTool(self.ToolbarL.ON_HULL_CHECK, False)
    else:
      self.ZAxisCombo.Disable()
      self.ZAxisLogButton.Disable()
      self.ZAxisScaleButton.Disable()
      if CanDoHulls:
        self.ToolbarL.EnableTool(self.ToolbarL.ON_HULL_CHECK, True)
    self.PlotL()

  def on_XLog_Button(self, event):
    btn = event.GetEventObject()
    if (self.LogState[X] == 0):
      self.LogState[X] = 1
      btn.SetBitmapLabel(self.bmp_log_on)
    else:
      self.LogState[X] = 0
      btn.SetBitmapLabel(self.bmp_log_off)
    self.Set_Scales()
    self.CanvasL.draw()
    
  def on_YLog_Button(self, event):
    btn = event.GetEventObject()
    if (self.LogState[Y] == 0):
      self.LogState[Y] = 1
      btn.SetBitmapLabel(self.bmp_log_on)
    else:
      self.LogState[Y] = 0
      btn.SetBitmapLabel(self.bmp_log_off)
    self.Set_Scales()
    self.CanvasL.draw()

  def on_ZLog_Button(self, event):
    btn = event.GetEventObject()
    if (self.LogState[Z] == 0):
      self.LogState[Z] = 1
      btn.SetBitmapLabel(self.bmp_log_on)
    else:
      self.LogState[Z] = 0
      btn.SetBitmapLabel(self.bmp_log_off)
    self.Set_Scales()
    self.CanvasL.draw()

  def on_XScale_Button(self, event):
    btn = event.GetEventObject()
    if (self.ScaleState[X] == 0):
      self.ScaleState[X] = 1
      btn.SetBitmapLabel(self.bmp_scale_on)
    else:
      self.ScaleState[X] = 0
      btn.SetBitmapLabel(self.bmp_scale_off)
    self.Compute_Scaled_Scatters()
    self.Display_Objects()    
    self.Set_Scales()
    self.CanvasL.draw()

  def on_YScale_Button(self, event):
    btn = event.GetEventObject()
    if (self.ScaleState[Y] == 0):
      self.ScaleState[Y] = 1
      btn.SetBitmapLabel(self.bmp_scale_on)
    else:
      self.ScaleState[Y] = 0
      btn.SetBitmapLabel(self.bmp_scale_off)
    self.Compute_Scaled_Scatters()
    self.Display_Objects()    
    self.Set_Scales()
    self.CanvasL.draw()

  def on_ZScale_Button(self, event):
    btn = event.GetEventObject()
    if (self.ScaleState[Z] == 0):
      self.ScaleState[Z] = 1
      btn.SetBitmapLabel(self.bmp_scale_on)
    else:
      self.ScaleState[Z] = 0
      btn.SetBitmapLabel(self.bmp_scale_off)
    self.Compute_Scaled_Scatters()
    self.Display_Objects(True)    
    self.Set_Scales()
    self.CanvasL.draw()

  def on_Prev_Button(self, event):
    slider_old_value = self.FrameSlider.GetValue()
    slider_new_value = slider_old_value - 1
    if (slider_new_value >= 1):
      self.FrameSlider.SetValue(slider_new_value)
      self.FocusOnFrame = slider_new_value
      self.Display_Objects()    
      self.Set_Scales()
      self.CanvasL.draw()

  def on_Next_Button(self, event):
    slider_old_value = self.FrameSlider.GetValue()
    slider_new_value = slider_old_value + 1
    if (slider_new_value <= NumberOfFrames):
      self.FrameSlider.SetValue(slider_new_value)
      self.FocusOnFrame = slider_new_value
      self.Display_Objects()    
      self.Set_Scales()
      self.CanvasL.draw()
 
  def on_Play_Button(self, event):
    self.DisableControls()
    if (self.CurrentView == VIEW_FRAMES):
      self.PlayingCurrentFrame = 1
      self.PlayTimer.Start(0, oneShot=True)
    elif (self.CurrentView == VIEW_TRACKING):
      self.Display_Paths()
      animation.TimedAnimation.__init__(self, self.FigL, interval=self.AnimationPeriod, repeat=False, blit=True)

  def on_Frame_Change(self, event):
    self.FocusOnFrame = self.FrameSlider.GetValue()
    self.Display_Objects()
    self.Set_Scales()
    self.CanvasL.draw()

  def Select_Objects(self):
    now_showing = self.NowShowing
    if self.CurrentView == VIEW_TRACKING:
      if self.ScaleState[X] or self.ScaleState[Y] or self.ScaleState[Z]:
        next_showing = SHOW_OBJECTS_SCALED
      else:
        next_showing = SHOW_OBJECTS_NORMAL
    elif self.CurrentView == VIEW_FRAMES:
      next_showing = SHOW_OBJECTS_NORMAL

    # if (now_showing != next_showing):
    #   self.Hide_Objects( HIDE_ALL )

    self.NowShowing = next_showing
    if (self.NowShowing == SHOW_OBJECTS_NORMAL):
      self.ShowingObjects = self.Objects
    else:
      self.ShowingObjects = self.ObjectsScaled

  def on_Tracking_Button(self, event):
    btn = event.GetEventObject()
    if (self.CurrentView == VIEW_FRAMES):
      self.CurrentView = VIEW_TRACKING
      self.PrevButton.Disable()
      self.NextButton.Disable()
      self.FrameSlider.Disable()
      self.TimelineButton.Disable()
      self.ToolbarL.ToggleTool(self.ToolbarL.ON_SCATTER_CHECK,  False)
      self.ToolbarL.ToggleTool(self.ToolbarL.ON_HULL_CHECK,     False)
      self.ToolbarL.ToggleTool(self.ToolbarL.ON_CENTROID_CHECK, True)
      self.Display_Objects()
      btn.SetBitmapLabel(self.bmp_frames_view)
      self.FrameBox.SetLabel("Viewing trajectories")
    else:
      self.CurrentView = VIEW_FRAMES
      self.PrevButton.Enable()
      self.NextButton.Enable()
      self.FrameSlider.Enable()
      self.TimelineButton.Enable()
      self.ToolbarL.ToggleTool(self.ToolbarL.ON_SCATTER_CHECK,  True)
      self.ToolbarL.ToggleTool(self.ToolbarL.ON_HULL_CHECK,     False)
      self.ToolbarL.ToggleTool(self.ToolbarL.ON_CENTROID_CHECK, False)
      self.Display_Objects()
      btn.SetBitmapLabel(self.bmp_trajectory_view)
      self.FrameBox.SetLabel("Viewing frame")
    self.Set_Scales()
    self.CanvasL.draw()

  def on_Timeline_Button(self, event):
    subprocess.Popen(["wxparaver", Traces[self.FocusOnFrame-1], INSTALLATION_PATH+"/etc/clusterid.cfg"])

  def on_Prediction_Change(self, event):
    txt = event.GetEventObject()
    try:
      int(txt.GetValue())
    except:
      txt.SetValue("0")
    value = int(txt.GetValue())
    if (value < 0):
      txt.SetValue("0")
    self.PlotR()

  def on_RegressionModel_Change(self, event):
    if (self.GetFittingSamples() > 0):
      self.PlotR()

#
# main()
#

def Usage():
  print ""
  print "Error: Invalid arguments!"
  print ""
  print "USAGE:"
  print "  xtrack <tracking_output.xtrack>"
  print ""

#
# Parse arguments
#
argc = len(sys.argv)

if (argc != 2):
  Usage()
  sys.exit(-1) 

Config = ConfigParser.ConfigParser()
Config.read(sys.argv[1])

def ReadConfig(section):
  dict = {}
  options = Config.options(section)
  for option in options:
    dict[option] = Config.get(section, option)
  return dict
NumberOfFrames = int(ReadConfig('Info')['frames'])

app = wx.PySimpleApp(False)
app.main = MainFrame(None, "Tracking")
app.main.Show()
app.MainLoop()
